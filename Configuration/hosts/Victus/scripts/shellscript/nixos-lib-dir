#!/bin/sh

main() {
	_name="nixos-lib-dir"
	_docs="documentation/scripts/nixos-lib-dir.md"
	_desc="Find most recent lib path in Nix store (cached)"
	_deps="Requires GNU coreutils (guaranteed on NixOS/Nix systems)"

	set_defaults
	parse_args "$@" || return "$EXIT_ARG_ERROR"
	init_environment || return $?
	execute
}

set_defaults() {
	#~@ Configuration
	cache="/tmp/${_name}"       #? Cache file location
	max_age=10                  #? Cache TTL in minutes
	pattern='*-nixos/nixos/lib' #? Nix store path pattern to search

	#~@ Exit codes
	EXIT_SUCCESS=0
	EXIT_NO_MATCH=1
	EXIT_MISSING_TOOL=2
	EXIT_ARG_ERROR=3
	EXIT_PERMISSION_ERROR=4

	#~@ Flags
	unset refresh_cache  #? Flag: unset = use cache, set = force refresh
	unset use_fd         #? Flag: set if fd is available
	unset use_hyperfine  #? Flag: set if hyperfine is available
	unset benchmark_mode #? Flag: set to compare fd vs find performance
	unset clipboard_cmd  #? Command to use for clipboard (wl-copy or xclip)
	unset verbose        #? Flag: set to show informational messages
	unset silent         #? Flag: set to supress all output, including path
}

init_environment() {
	#~@ Verify required GNU tools

	#? Check for find command
	if command -v find >/dev/null 2>&1; then :; else
		printf "ERROR: 'find' command not found\n" >&2
		return "$EXIT_MISSING_TOOL"
	fi

	#? Ensure /tmp is writable
	if [ -w "/tmp" ]; then :; else
		printf "ERROR: /tmp is not writable\n" >&2
		return "$EXIT_PERMISSION_ERROR"
	fi

	#~@ Check for optional fast tools

	#? Check if fd is available (much faster than find)
	if command -v fd >/dev/null 2>&1; then
		use_fd=true
	fi

	#? Check if hyperfine is available (for advanced benchmarking)
	if command -v hyperfine >/dev/null 2>&1; then
		use_hyperfine=true
	fi

	#~@ Check for clipboard utilities

	#? Check for Wayland clipboard (wl-clipboard)
	if command -v wl-copy >/dev/null 2>&1; then
		clipboard_cmd="wl-copy"
	#? Check for X11 clipboard (xclip)
	elif command -v xclip >/dev/null 2>&1; then
		clipboard_cmd="xclip -selection clipboard"
	#? Check for X11 clipboard (xsel)
	elif command -v xsel >/dev/null 2>&1; then
		clipboard_cmd="xsel --clipboard --input"
	fi

	return "$EXIT_SUCCESS"
}

execute() {
	#> Perform benchmark if requested
	if [ -n "${benchmark_mode:-}" ]; then
		benchmark
		return $?
	fi

	#> Retrieve path from cache if available
	if check_cache; then
		use_cache
		print_path
		return "$EXIT_SUCCESS"
	fi

	#> Search for path
	find_latest
	print_path
}

print_path() {
	if [ -n "$path" ]; then
		[ -n "${silent:-}" ] || printf "%s\n" "$path"
		copy_to_clipboard "$path"
		return "$EXIT_SUCCESS"
	else
		printf "ERROR: No directories found in store that match the pattern: %s\n" "$pattern" >&2
		return "$EXIT_NO_MATCH"
	fi
}

print_verbose() {
	[ -n "${verbose:-}" ] && printf "%s\n" "$1"
}

print_option_error() {
	printf "ERROR: %s requires an argument\n" "$1" >&2
	printf "Try '%s --help' for usage information\n" "$_name" >&2
}

check_cache() {
	#~@ Handle cache refresh

	#? Check if refresh was requested
	if [ -n "${refresh_cache:-}" ]; then
		#> Delete the existing cache file
		rm -f "$cache"
		#> Clear refresh flag
		unset refresh_cache
		return 1
	fi

	#~@ Validate cache file

	#? Check if cache exists and is readable
	if [ ! -f "$cache" ] || [ ! -r "$cache" ]; then
		return 1
	fi

	#~@ Check cache age

	#> Get cache modification time using GNU stat
	cache_time=$(stat -c %Y "$cache" 2>/dev/null || printf "0")
	#> Get current time
	now=$(date +%s)

	#? Verify we got a valid timestamp
	if [ "$cache_time" = "0" ]; then
		return 1
	fi

	#> Calculate age in minutes
	age=$(((now - cache_time) / 60))
	#? Check if cache is still fresh
	[ "$age" -le "$max_age" ]
}

copy_to_clipboard() {
	#~@ Copy text to clipboard if available

	#? Check if clipboard command is available
	if [ -z "${clipboard_cmd:-}" ]; then
		return 1
	fi

	#> Copy to clipboard
	if printf "%s" "$1" | eval "$clipboard_cmd" 2>/dev/null; then
		print_verbose "ðŸ“‹ Copied to clipboard"
		return 0
	else
		return 1
	fi
}

use_cache() {
	#~@ Display cache info and retrieve path

	#> Get cache timestamp
	cache_time=$(stat -c %Y "$cache" 2>/dev/null || printf "0")
	#> Get current time
	now=$(date +%s)

	if [ "$cache_time" != "0" ]; then
		#> Calculate cache age
		age=$(((now - cache_time) / 60))
		if [ "$age" -eq 0 ]; then
			print_verbose "Found in cache: '$cache' (<1 min old)"
		else
			print_verbose "Found in cache: '$cache' ($age min old)"
		fi
	else
		print_verbose "Using cached result"
	fi

	#> Read cached path
	path=$(cat "$cache")
}

find_latest() {
	#~@ Search Nix store for lib directory

	if [ -n "${use_fd:-}" ]; then
		#> Using fd (fast)
		print_verbose "Searching with fd..."

		#> Convert glob pattern to regex for fd
		#? Pattern: *-nixos/nixos/lib -> .*-nixos/nixos/lib$
		fd_pattern=$(
			printf '%s' "$pattern" |
				sed 's/^\*/.*/' |
				sed 's/$/$/'
		)

		#> Search and sort by modification time
		result_fd=$(
			fd \
				--type d \
				--full-path "$fd_pattern" \
				/nix/store \
				--exec stat -c '%Y %n' 2>/dev/null
		)
	else
		#> Using find (slower but always available)
		print_verbose \
			"Searching with find (consider installing 'fd' for faster results)..."

		#> Use GNU find's -printf
		result_find=$(
			find /nix/store \
				-type d \
				-path "$pattern" \
				-printf '%T@ %p\n' 2>/dev/null
		)
	fi

	result=$(
		printf "%s" "${result_fd:-${result_find:-}}" |
			sort -rn |
			head -n 1 |
			cut -d' ' -f2-
	)

	#~@ Process results

	#? Check if we found anything
	if [ -n "$result" ]; then
		#> Try to write to cache
		if ! printf '%s\n' "$result" >"$cache" 2>/dev/null; then
			printf "WARNING: Failed to write cache\n" >&2
		fi
		#> Store the result
		path="$result"
		return 0
	else
		#> Clean up stale cache
		rm -f "$cache"
		return 1
	fi
}

benchmark() {
	#~@ Benchmark fd vs find performance

	#> Ensure fd is available for comparison
	if [ -z "${use_fd:-}" ]; then
		printf "fd not available - skipping benchmark\n"
		printf "Install fd with: nix-shell -p fd\n"
		return "$EXIT_MISSING_TOOL"
	fi

	#~@ Use hyperfine if available for advanced benchmarking
	if [ -n "${use_hyperfine:-}" ]; then
		printf "=== Performance Benchmark (using hyperfine) ===\n"
		printf "\n"

		#| Create temporary wrapper scripts for hyperfine
		tmp_find=$(mktemp)
		tmp_fd=$(mktemp)
		trap 'rm -f "$tmp_find" "$tmp_fd"' EXIT INT TERM

		#> Write find command to temp script
		cat >"$tmp_find" <<-'EOF'
			#!/bin/sh
			pattern='*-nixos/nixos/lib'
			find /nix/store -type d -path "$pattern" -printf '%T@ %p\n' 2>/dev/null |
				sort -rn | head -n 1 | cut -d' ' -f2-
		EOF
		chmod +x "$tmp_find"

		#> Write fd command to temp script
		cat >"$tmp_fd" <<-'EOF'
			#!/bin/sh
			pattern='*-nixos/nixos/lib'
			fd_pattern=$(printf '%s' "$pattern" | sed 's/^\*/.*/' | sed 's/$/$/')
			fd -t d -p "$fd_pattern" /nix/store -x stat -c '%Y %n' 2>/dev/null |
				sort -rn | head -n 1 | cut -d' ' -f2-
		EOF
		chmod +x "$tmp_fd"

		#> Run hyperfine benchmark
		hyperfine \
			--warmup 2 \
			--min-runs 5 \
			--export-markdown /tmp/benchmark-results.md \
			--command-name "find" "$tmp_find" \
			--command-name "fd" "$tmp_fd"

		printf "\n"
		printf "Results saved to: /tmp/benchmark-results.md\n"

		return 0
	fi

	#~@ Fallback to manual timing
	printf "=== Performance Benchmark: fd vs find ===\n"
	printf "(Install hyperfine for more detailed benchmarks: nix-shell -p hyperfine)\n"
	printf "\n"
	printf "Warming up both tools...\n"

	#> Warm up both tools
	use_fd=true
	find_latest >/dev/null 2>&1
	unset use_fd
	find_latest >/dev/null 2>&1

	run() {
		start=$(date +%s%N 2>/dev/null || date +%s)
		find_latest >/dev/null 2>&1
		stop=$(date +%s%N 2>/dev/null || date +%s)

		#> Calculate elapsed time
		if [ "${#start}" -gt 10 ]; then
			#? Nanosecond precision available
			elapsed=$(((stop - start) / 1000000))
		else
			#? Second precision fallback
			elapsed=$((stop - start * 1000))
		fi

		printf "%s" "$elapsed"
	}

	#~@ Test find performance
	printf "Running find...\n"
	elapsed_find="$(run)"

	#~@ Test fd performance
	use_fd=true
	printf "Running fd...\n"
	elapsed_fd="$(run)"

	#~@ Display results
	printf "\n"
	printf "â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\n"
	printf "â”‚ %-15s â”‚ %10s ms â”‚\n" "Tool" "Time"
	printf "â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\n"
	printf "â”‚ %-15s â”‚ %10d ms â”‚\n" "find" "$elapsed_find"
	printf "â”‚ %-15s â”‚ %10d ms â”‚\n" "fd" "$elapsed_fd"
	printf "â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n"
	printf "\n"

	#~@ Calculate and display speedup
	if [ "$elapsed_fd" -lt "$elapsed_find" ]; then
		speedup=$((elapsed_find * 100 / elapsed_fd))
		improvement=$((speedup - 100))
		printf "âœ“ fd is %d%% faster than find (%dx speedup)\n" \
			"$improvement" "$((speedup / 100))"
	elif [ "$elapsed_find" -lt "$elapsed_fd" ]; then
		speedup=$((elapsed_fd * 100 / elapsed_find))
		improvement=$((speedup - 100))
		printf "âš  find is %d%% faster than fd (%dx speedup)\n" \
			"$improvement" "$((speedup / 100))"
	else
		printf "â‰ˆ Both tools performed equally\n"
	fi
}

parse_args() {
	while [ $# -gt 0 ]; do
		case "$1" in
		-c | --cache)
			if [ -n "$2" ]; then
				cache="$2"
				shift
			else
				print_option_error "$1"
				return "$EXIT_ARG_ERROR"
			fi
			;;
		-a | --age)
			if [ -n "$2" ]; then
				max_age="$2"
				shift
			else
				print_option_error "$1"
				return "$EXIT_ARG_ERROR"
			fi
			;;
		-p | --pattern)
			if [ -n "$2" ]; then
				pattern="$2"
				refresh_cache=true
				shift
			else
				print_option_error "$1"
				return "$EXIT_ARG_ERROR"
			fi
			;;
		-f | --refresh-cache)
			refresh_cache=true
			;;
		-b | --benchmark)
			benchmark_mode=true
			;;
		-d | --verbose)
			verbose=true
			;;
		-q | --quiet)
			unset verbose
			silent=true
			;;
		-h | --help)
			printf "Usage: %s [OPTIONS]\n" "$_name"
			printf "  -c, --cache FILE     Cache file (default: %s)\n" "$cache"
			printf "  -a, --age MINUTES    Max cache age (default: %d)\n" "$max_age"
			printf "  -p, --pattern GLOB   Search pattern (default: %s)\n" "$pattern"
			printf "  -f, --refresh-cache  Force cache refresh\n"
			printf "  -b, --benchmark      Compare fd vs find\n"
			printf "  -q, --quiet          Supress messages\n"
			printf "  -d, --verbose        Show informational messages\n"
			printf "  -h, --help           Show this help\n"
			printf "\nDocumentation: %s\n" "$_docs"
			return 0
			;;
		-*)
			printf "ERROR: Unknown option: %s\n" "$1" >&2
			printf "Try '%s --help' for usage information\n" "$_name" >&2
			return "$EXIT_ARG_ERROR"
			;;
		*)
			printf "ERROR: Unexpected argument: %s\n" "$1" >&2
			printf "Try '%s --help' for usage information\n" "$_name" >&2
			return "$EXIT_ARG_ERROR"
			;;
		esac
		shift
	done
}

main "$@"
