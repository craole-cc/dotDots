#!/bin/sh

main() {
    #@ set defaults
    verbosity=3
    action="show"
    bins=""
    debug=""

    #@ Define the path to the bin directory
    parse_arguments "$@" || return 1

    #@ Perform the requested action
    perform_action
}

parse_arguments() {
    while [ "$#" -gt 0 ]; do
        case "$1" in
        --show)
            action="show"
            ;;
        --clean)
            action="clean"
            ;;
        --action)
            if [ "$2" ]; then
                action="$2"
                shift
            else
                printf "'%s' requires an argument [ append | prepend | show ]\n" "$1"
                return 1
            fi
            ;;
        --append)
            action="append"
            ;;
        --prepend)
            action="prepend"
            ;;
        --dir*)
            if [ "$2" ]; then
                shift
                if [ -z "$bins" ]; then
                    bins="$(resolved_path "$1")"
                else
                    bins="$(
                        printf "%s\n%s" "$bins" "$(resolved_path "$1")"
                    )"
                fi
            else
                printf "'%s' requires an argument\n" "$1"
                return 1
            fi
            ;;
        *)
            if [ -z "$bins" ]; then
                bins="$(resolved_path "$1")"
            else
                bins="$(
                    printf "%s\n%s" "$bins" "$(resolved_path "$1")"
                )"
            fi
            ;;
        esac
        shift
    done
}

perform_action() {
    case "$action" in
    append | prepend)
        #@ Validate that a directory was provided
        if [ -z "$bins" ]; then
            printf "ERROR: No path provided\n"
            return 1
        fi
        add_to_path
        ;;
    clean)
        clean_path
        ;;
    show)
        show_bins "$PATH"
        ;;
    esac
}

recursive_paths() {
    for bin in "$@"; do
        if command -v fd >/dev/null 2>&1; then
            #@ Add the results from fd
            fd . "$bin"

            #@ Include the lookup directory
            printf "%s\n" "$bin"
        else
            #@ Fallback to find
            find "$bin"
        fi
    done | sort
}

resolved_path() {
    path="$1"
    if command -v realpath >/dev/null 2>&1; then
        realpath "$path"
    else
        if [ -d "$path" ]; then
            (cd "$path" && pwd)
        else
            dir="$(cd "$(dirname "$path")" && pwd)"
            printf '%s/%s\n' "$dir" "$(basename "$path")"
        fi
    fi
}

os_type() {
    case "$(uname -a | tr '[:upper:]' '[:lower:]')" in
    *linux*) os_type="linux" ;;
    *darwin*) os_type="mac" ;;
    *) os_type="windows" ;;
    esac

    #TODO This is utterly inadequete, just temporary
    printf "%s" "$os_type"
}
add_to_path() {
    #@ Initialize variables
    counter=1

    #@ Process sources recursively
    [ "$debug" ] && {
        for bin_path in $(recursive_paths "$bins"); do
            #@ Increment the counter
            printf "  %4d %s\n" "$counter" "$bin_path"
            counter=$((counter + 1))
        done
        return 0
    }

    #@ Update PATH directories
    for bin_path in $(recursive_paths "$bins"); do
        [ -d "$bin_path" ] &&
            case ":${PATH}:" in
            *:"$bin_path":*) ;;
            *)
                case "$action" in
                prepend)
                    PATH="${bin_path}${PATH:+:$PATH}"
                    _action="Appended"
                    ;;
                append)
                    PATH="${PATH:+$PATH:}${bin_path}"
                    _action="Perpended"
                    ;;
                esac

                [ "$verbosity" -gt 1 ] &&
                    printf "    %s to PATH: %s\n" "$_action" "${bin_path}"
                ;;
            esac

        #@ Make scripts executable
        [ -f "$bin_path" ] &&
            case "$(os_type)" in windows) ;;
            *)
                if chmod +x "$bin_path" >/dev/null 2>&1; then
                    printf "    Script initialized: %s\n" "${bin_path}"
                else
                    printf "    Failed to make %s executable: %s\n" "${bin_path}" "$?"
                fi
                ;;
            esac
    done
}

show_bins() {
    printf "%s\n" "${1:-"$PATH"}" | tr ':' '\n' | nl -s '  '
}

is_absolute_path() {
    case "$1" in
    /*) return 0 ;; # Path starts with /, so it's absolute
    *) return 1 ;;  # Otherwise, it's not absolute
    esac
}

clean_path() {
    #@ Initialize variables
    cleaned_path=""
    IFS=':'

    #@ Clean the path
    for path in $PATH; do
        if is_absolute_path "$path"; then
            if [ -z "$cleaned_path" ]; then
                cleaned_path="$path"
            else
                cleaned_path="$cleaned_path:$path"
            fi
        fi
    done

    #@ Reset IFS to default
    unset IFS

    #@ Export the cleaned path
    if [ "$debug" ]; then
        show_bins "$cleaned_path"
    else
        PATH="$cleaned_path"
        export PATH
    fi
}

#@ Execute the main function with the provided argument
main "$@"
