# ===========================================================================
# DOTS RC - Universal shell configuration loader for DOTS
# Supports: bash, zsh, sh, fish, PowerShell, Nushell
# ===========================================================================

# === POSIX SHELLS (bash, zsh, sh) ===
if [ -n "${BASH_VERSION:-}${ZSH_VERSION:-}${POSH_VERSION:-}" ]; then
  #@ Determine shell type for cleaner messaging
  if [ -n "${BASH_VERSION:-}" ]; then
    SHELL_NAME="bash"
    CONFIG_FILE="bashrc"
  elif [ -n "${ZSH_VERSION:-}" ]; then
    SHELL_NAME="zsh"
    CONFIG_FILE="zshrc"
  else
    SHELL_NAME="sh"
    CONFIG_FILE="shrc"
  fi

  printf "VERBOSE: Attempting to initialize DOTS for shell: %s...\n" "${SHELL_NAME}"

  #@ Validate DOTS environment variable
  if [ -z "${DOTS:-}" ]; then
    printf "ERROR: DOTS environment variable must be set\n" >&2
    return 1 2>/dev/null || exit 1
  fi

  #@ Validate DOTS directory exists
  if [ ! -d "$DOTS" ]; then
    printf "ERROR: DOTS directory '%s' does not exist\n" "$DOTS" >&2;
    return 1 2>/dev/null || exit 1
  fi

  #@ Load shell-specific configuration
  CONFIG_PATH="$DOTS/$CONFIG_FILE"
  if [ -f "$CONFIG_PATH" ]; then
    . "$CONFIG_PATH"
    printf "INFORMATION: Initialized DOTS using '%s'\n" "$CONFIG_FILE"
  else
    printf "WARNING: Configuration file '%s' not found\n" "$CONFIG_PATH" >&2
  fi

  return 0 2>/dev/null || exit 0
fi

# === FISH SHELL ===
# Fish ignores lines starting with '#' except when they start with '#;'
#; if not set -q DOTS; echo "ERROR: DOTS environment variable must be set" >&2; exit 1; end; if not test -d $DOTS; echo "ERROR: DOTS directory '$DOTS' does not exist" >&2; exit 1; end; echo "Loading fish configuration..."; set config_file $DOTS/fishrc; if test -f $config_file; source $config_file; echo "✓ Loaded fishrc"; else; echo "WARNING: Configuration file '$config_file' not found" >&2; end; exit 0

# === POWERSHELL ===
$Global:Verbosity = "Trace"
$Global:VerbosePreference = 'SilentlyContinue'
$Global:DebugPreference = 'SilentlyContinue'
$Global:InformationPreference = 'SilentlyContinue'
$Global:WarningPreference = 'SilentlyContinue'
$Global:ErrorActionPreference = 'SilentlyContinue'
# $Global:VerbosePreference = 'Continue'
# $Global:DebugPreference = 'Continue'
# $Global:InformationPreference = 'Continue'
# $Global:WarningPreference = 'Continue'
# $Global:ErrorActionPreference = 'Continue'

function Set-Environment {

  #@ Validate DOTS environment variable
  if (-not $env:DOTS) {
      Write-Error "ERROR: DOTS environment variable must be set"
      exit 1
  }

  #@ Define the DOTS Binaries path globally
  $Global:DOTS_BIN = Resolve-PathPOSIX (Join-Path -Path $Global:DOTS -ChildPath 'Bin')
  [Environment]::SetEnvironmentVariable('DOTS_BIN', $Global:DOTS_BIN, 'Process')
  Set-Item -Path 'env:DOTS_BIN' -Value $Global:DOTS_BIN
  Write-Debug "DOTS_BIN => $Global:DOTS_BIN"

  #@ Define the DOTS Binaries path globally
  $Global:DOTS_BIN_PS = Resolve-PathPOSIX (Join-Path -Path $Global:DOTS_BIN -ChildPath 'powershell')
  [Environment]::SetEnvironmentVariable('DOTS_BIN_PS', $Global:DOTS_BIN_PS, 'Process')
  Set-Item -Path 'env:DOTS_BIN_PS' -Value $Global:DOTS_BIN_PS
  Write-Debug "DOTS_BIN_PS => $Global:DOTS_BIN_PS"

  #@ Define the DOTS Modules path globally
  $Global:DOTS_MOD = Resolve-PathPOSIX (Join-Path -Path $Global:DOTS -ChildPath 'Modules/')
  [Environment]::SetEnvironmentVariable('DOTS_MOD', $Global:DOTS_MOD, 'Process')
  Set-Item -Path 'env:DOTS_MOD' -Value $Global:DOTS_MOD
  Write-Debug "DOTS_MOD => $Global:DOTS_MOD"

  #@ Define the Powershell Modules path globally
  $Global:DOTS_MOD_PS = Resolve-PathPOSIX (Join-Path -Path $Global:DOTS_MOD -ChildPath 'powershell')
  [Environment]::SetEnvironmentVariable('DOTS_MOD_PS', $Global:DOTS_MOD_PS, 'Process')
  Set-Item -Path 'env:DOTS_MOD_PS' -Value $Global:DOTS_MOD_PS
  Write-Debug "DOTS_MOD_PS => $Global:DOTS_MOD_PS"
}

function Invoke-Binaries_REV {
    #@ Ensure the DOTS Binaries directory was found and normalize it
    if (-not $env:DOTS_BIN) {
        Write-Error "ERROR: DOTS Binaries directory not set"
        exit
    }

    Write-Verbose "Searching for binaries in '$env:DOTS_BIN'..."

    #@ Get all subdirectories recursively
    $allDirs = Get-ChildItem -Path $env:DOTS_BIN -Recurse -Directory -ErrorAction SilentlyContinue

    #@ Filter out excluded directories
    $excludedNames = @('review', 'temp', 'tmp', 'archive')
    $rawDirs = @()

    foreach ($dir in $allDirs) {
        $shouldExclude = $false

        #@ Check if the directory path contains any excluded folder names
        #@ Use the parent path hierarchy to check each level
        $currentPath = $dir.FullName
        $basePath = $env:DOTS_BIN

        #@ Get the relative path from DOTS_BIN to this directory
        if ($currentPath.StartsWith($basePath)) {
            $relativePath = $currentPath.Substring($basePath.Length).TrimStart('\', '/')

            #@ Split the relative path and check each directory level
            $pathSegments = $relativePath -split '[\\/]' | Where-Object { $_ -ne '' }

            foreach ($segment in $pathSegments) {
                if ($segment -in $excludedNames) {
                    $shouldExclude = $true
                    break
                }
            }
        }

        if (-not $shouldExclude) {
            $rawDirs += $dir.FullName
        }
    }

    #@ Also include the root DOTS_BIN directory
    $rawDirs = @($env:DOTS_BIN) + $rawDirs

    #@ Normalize paths using Resolve-PathPOSIX
    $binaryDirs = @()
    foreach ($dir in $rawDirs) {
        try {
            $normalizedPath = Resolve-PathPOSIX $dir
            if ($normalizedPath) {
                $binaryDirs += $normalizedPath
            }
        }
        catch {
            Write-Warning "Could not resolve path: $dir - $_"
        }
    }

    #@ Remove duplicates after normalization
    $binaryDirs = $binaryDirs | Sort-Object -Unique

    #@ Get current PATH directories (filter out empty entries)
    $currentPathDirs = ($env:PATH -split ';') | Where-Object { $_ -ne '' }

    #@ Find directories that aren't already in PATH
    $dirsToAdd = $binaryDirs | Where-Object { $_ -notin $currentPathDirs }

    if ($dirsToAdd) {
        Write-Verbose "Adding $(@($dirsToAdd).Count) directories to PATH"
        $env:PATH += ";$($dirsToAdd -join ';')"
        Write-Host "Added directories to PATH:" -ForegroundColor Green
        $dirsToAdd | ForEach-Object { Write-Host "  $_" -ForegroundColor Gray }
    } else {
        Write-Verbose "All binary directories already in PATH"
    }
}

function Invoke-Binaries {

  #@ Ensure the Powershell Modules directory was found
  if (-not $env:DOTS_BIN_PS) {
      Write-Error "ERROR: DOTS Modules directory '$DOTS_BIN_PS' does not exist"
      exit 1
  }

  #@ Add the modules to PSModulePath (if not already there)
  if (-not ($env:PSModulePath -split ';' | Where-Object { $_ -eq $DOTS_BIN_PS })) {
      Write-Verbose "Adding $DOTS_BIN_PS to PSModulePath"
      $env:PSModulePath += ";$DOTS_BIN_PS"
  }

  #@ Import all modules
  Get-ChildItem -Path $DOTS_BIN_PS -Filter *.psm1 -Recurse | ForEach-Object {
      Import-Module $_.FullName -Force
  }

  Write-Output -Tag "Information" -NoNewLine "Initialized DOTS_BIN using '${DOTS_BIN_PS}'"
}

function Invoke-Modules {

  #@ Ensure the Powershell Modules directory was found
  if (-not $env:DOTS_MOD_PS) {
      Write-Error "ERROR: DOTS Modules directory '$DOTS_MOD_PS' does not exist"
      exit 1
  }

  #@ Add the modules to PSModulePath (if not already there)
  if (-not ($env:PSModulePath -split ';' | Where-Object { $_ -eq $DOTS_MOD_PS })) {
      Write-Verbose "Adding $DOTS_MOD_PS to PSModulePath"
      $env:PSModulePath += ";$DOTS_MOD_PS"
  }

  #@ Import all modules
  Get-ChildItem -Path $DOTS_MOD_PS -Filter *.psm1 -Recurse | ForEach-Object {
      # Import-Module $_.FullName -Force 5>$null 4>$null 3>$null 2>$null 1>$null
      Import-Module $_.FullName -Force
  }

  Write-Output -Tag "Information" -NoNewLine "Initialized DOTS using '${DOTS_MOD_PS}'"
}

Set-Environment
Invoke-Modules
Invoke-Binaries
exit

# === NUSHELL ===
# Nushell ignores lines starting with '#' except when they start with '#nu'
#nu if ($env.DOTS == null) { print "ERROR: DOTS environment variable must be set" | ansi red; exit 1 }; if not ($env.DOTS | path exists) { print $"ERROR: DOTS directory '($env.DOTS)' does not exist" | ansi red; exit 1 }; print "Loading Nushell configuration..." | ansi cyan; let config_file = $"($env.DOTS)/nushell_config.nu"; if ($config_file | path exists) { source $config_file; print "✓ Loaded nushell_config.nu" | ansi green } else { print $"WARNING: Configuration file '($config_file)' not found" | ansi yellow }; exit 0
