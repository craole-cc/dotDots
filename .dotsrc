#!/bin/sh
# shellcheck enable=all
# shellcheck disable=SC1090
# set -e #TODO: Use set -e temporarily for clean coding

main() {
	if [ -z "${DOTS:-}" ]; then
		printf "The required DOTS directory environment variable is not defined.\n"
		return 1
	elif [ ! -d "${DOTS:-}" ]; then
		printf "The DOTS directory is inaccessible: %s\n" "${DOTS:-}"
		return 1
	fi

	trap 'dots__cleanup' EXIT HUP INT TERM
	dots__cleanup
	dots__settings
	dots__utilities
	exec_and_time dots__environment


	# dots__environment
	# environment="$(exec_and_time dots__environment)"
	# dots__bin
	# dots__init_scripts #TODO: Move all to bin
	# echo "EDITOR: ${EDITOR}"
	# return
	# dots__set_global_env

	# dots__init_config

	# init_oh_my_posh config
	# init_starship

	# dots__init_scripts
	# dots__init_aliases
	# fetch_info
	# init_scripts
	# init_sh

	# init_bash
	# return
	# init_nushell
	# init_blesh
	# init_atuin
	# init_starship
	# init_fastfetch
	# init_tests || init_fastfetch || true
	# dots__pout --path --tail
	# dots__pout --path --head 50
	# echo "${PATH}" | tr ':' '\n'
	# pout_PATH
	# "${CMD_PATHMAN}"
	# fastfetch
	if [ "${verbosity:-0}" -lt "${verbosity_trace:-5}" ]; then :; else
		dots__pout --trace "DOTS initialized"
	fi
	# printf "DOTS initialized\n"

}

# dots__cleanup() {
# 	echo "cleaning up"
# 	#| Local Variables (dots__settings)
# 	unset ctx
# 	unset ctx_sep
# 	unset ctx_head
# 	unset ctx_tail
# 	unset verbosity
# 	unset verbosity_quiet
# 	unset verbosity_error
# 	unset verbosity_warn
# 	unset verbosity_info
# 	unset verbosity_debug
# 	unset verbosity_trace
# 	unset delimiter
# 	unset reset_cache
# 	unset editors_tui
# 	unset editors_gui
# 	unset timestamp
# }

dots__settings() {
	ctx="DOTS"
	timestamp="$(date '+%Y-%m-%d %H:%M:%S' 2>/dev/null || true)"
	ctx_sep=" | "
	ctx_head=">>- "
	ctx_tail=" ->> "
	verbosity=5 #? 0=quiet, 1=error, 2=warn, 3=info, 4=debug, 5=trace
	verbosity_quiet=0
	verbosity_error=1
	verbosity_warn=2
	verbosity_info=3
	verbosity_debug=4
	verbosity_trace=5
	delimiter="${DELIMITER:-"$(printf "\037")"}"
	reset_cache=1 #? 0=no, 1=yes
	editors_tui="hx:nvim:nano"
	editors_gui="code:zeditor:zed.exe"
}

dots__pout() {
	#@ Initialize garbage collection
	cleanup() {
		unset pout_msg pout_ctx pout_ctx_tag pout_tag path_limit arg path_limit_start
	} && cleanup
	trap 'cleanup' EXIT INT TERM HUP

	#@ Set default values
	ctx_sep=${ctx_sep:-"-|-"}
	pout_ctx=${ctx}
	path_limit_start="head"
	verbosity="${verbosity:-0}"
	verbosity_error="${verbosity_error:-1}"
	verbosity_warn="${verbosity_warn:-2}"
	verbosity_info="${verbosity_info:-3}"
	verbosity_debug="${verbosity_debug:-4}"
	verbosity_trace="${verbosity_trace:-5}"
	delimiter="${delimiter:-"${DELIMITER:-"$(printf "\037")"}"}"
	ifs="${IFS}"
	IFS="${delimiter}"

	#@ Parse arguments
	while [ "$#" -ge 1 ]; do
		case "$1" in
		--ctx)
			pout_ctx="$2"
			shift
			;;
		--trace)
			if [ "${verbosity}" -lt "${verbosity_trace}" ]; then return; else
				pout_tag="TRACE"
			fi
			;;
		--test)
			if [ "${verbosity}" -lt "${verbosity_trace}" ]; then return; else
				pout_tag="TEST"
			fi
			;;
		--debug)
			if [ "${verbosity}" -lt "${verbosity_debug}" ]; then return; else
				pout_tag="DEBUG"
			fi
			;;
		--info)
			if [ "${verbosity}" -lt "${verbosity_info}" ]; then return; else
				pout_tag="INFO"
			fi
			;;
		--warn)
			if [ "${verbosity}" -lt "${verbosity_warn}" ]; then return; else
				pout_tag="WARN"
			fi
			;;
		--err* | --fatal | --fail*])
			if [ "${verbosity}" -lt "${verbosity_error}" ]; then return; else
				pout_tag="ERROR"
			fi
			;;
		--path)
			pout_tag="PATH"
			shift
			if [ "$#" -ge 1 ]; then
				case "$1" in
				--tail | --head)
					path_limit_start="${1#--}"
					path_limit="${path_limit:-1}"
					shift
					;;
				*)
					path_limit="${1:-all}"
					shift
					;;
				esac
			fi
			break
			;;
		--)
			shift
			break
			;;
		--*)
			shift
			for arg in "$@"; do
				pout_msg="${pout_msg:+"${pout_msg}${delimiter}"}${arg:-}"
			done
			break
			;;
		*)
			pout_msg="${pout_msg:+"${pout_msg}${delimiter}"}${1}"
			;;
		esac
		shift
	done

	#@ Build tag with flag and context, if necessary
	pout_ctx="${pout_ctx:-"${ctx}"}"
	if [ -z "${pout_tag:-}" ]; then :; else
		case "${pout_tag:-}" in
		PATH) pout_ctx_tag="${pout_ctx}${ctx_sep}${pout_tag}" ;;
		*) pout_ctx_tag="${pout_tag}${ctx_sep}${pout_ctx}" ;;
		esac
	fi

	#@ Update the style of the context tag
	if [ -z "${pout_ctx_tag}" ]; then :; else
		pout_ctx_tag_head="${ctx_head:-"/> "}"
		pout_ctx_tag_tail="${ctx_tail:-" <\ "}"
		pout_ctx_tag="${pout_ctx_tag_head}${pout_ctx_tag}${pout_ctx_tag_tail}"
	fi

	#@ Replace the delimiter with a space
	if [ -n "${pout_msg}" ]; then
		pout_msg="$(printf "%b" "${pout_msg}" | tr "${delimiter}" " ")"
	fi

	#@ Print the message based on tag - optimized conditionals
	case "${pout_tag}" in
	TEST)
		printf "\n%b%b\n" "${pout_ctx_tag}" "${pout_msg}"
		eval "${pout_msg}"
		;;
	TRACE | DEBUG | INFO | WARN | ERROR)
		printf "%b%b\n" "${pout_ctx_tag}" "${pout_msg}"
		;;
	PATH | Path | path)
		printf "%s\n" "${pout_ctx_tag}"

		#@ Initialize PATH processing variables
		: "${path_count:=0}"
		: "${i:=0}"
		: "${p:=}"

		#@ Count paths efficiently
		for p in $(printf "%s" "${PATH}" | tr ':' ' '); do
			path_count=$((path_count + 1))
		done

		[ "${path_count}" -gt 0 ] || {
			printf "%s\n" "[ERROR] /> ${ctx} <\ PATH is empty" >&2
			IFS="${ifs}"
			return 1
		}

		#@ Only use numeric path_limit
		if [ -n "${path_limit}" ] && [ "${path_limit}" != "all" ]; then
			case "${path_limit_start}" in
			tail)
				i=$((path_count - path_limit))
				[ "${i}" -lt 0 ] && i=0
				;;
			*)
				i=0
				;;
			esac

			#@ Print paths with limit
			: "${current:=0}"
			for p in $(printf "%s" "${PATH}" | tr ':' ' '); do
				current=$((current + 1))
				if [ "${current}" -gt "${i}" ] && [ "${current}" -le "$((i + path_limit))" ]; then
					printf "%3d %s %s\n" "${current}" "${ctx_sep}" "${p}"
				fi
			done
		else
			#@ Print all paths
			i=1
			for p in $(printf "%s" "${PATH}" | tr ':' ' '); do
				printf "%3d %s %s\n" "${i}" "${ctx_sep}" "${p}"
				i=$((i + 1))
			done
		fi
		;;
	*)
		printf "%s" "${pout_msg}"
		;;
	esac

	#@ Restore IFS
	IFS="${ifs}"
}

dots__pout_SLOW() {
	pout__main() {
		pout__set_local_env
		pout__parse_arguments "$@"
		pout__execute
	}

	pout__set_local_env() {
		ctx_sep="${ctx_sep:-"-|-"}"
		pout_tag=""
		pout_ctx=""
		pout_msg=""
		pout_ctx_tag=""
		path_limit=""
		path_limit_start="head"
		path=""
		delimiter="${DELIMITER:-"$(printf "\037")"}"
		old_ifs="${IFS}"
		IFS="${delimiter}"
	}

	pout__parse_arguments() {
		while [ "$#" -ge 1 ]; do
			case "$1" in
			--ctx)
				pout_ctx="$2"
				shift
				;;
			--trace)
				if [ "${verbosity:-0}" -ge "${VERBOSITY_TRACE:-5}" ]; then
					pout_tag="TRACE"
				else return; fi
				;;
			--test)
				if [ "${verbosity:-0}" -ge "${VERBOSITY_TRACE:-5}" ]; then
					pout_tag="TEST"
				else return; fi
				;;
			--debug)
				if [ "${verbosity:-0}" -ge "${VERBOSITY_DEBUG:-4}" ]; then
					pout_tag="DEBUG"
				else return; fi
				;;
			--info)
				if [ "${verbosity:-0}" -ge "${VERBOSITY_INFO:-3}" ]; then
					pout_tag="INFO"
				else return; fi
				;;
			--warn)
				if [ "${verbosity:-0}" -ge "${VERBOSITY_WARN:-2}" ]; then
					pout_tag="WARN"
				else return; fi
				;;
			--err* | --fatal | --fail*])
				if [ "${verbosity:-0}" -ge "${VERBOSITY_ERROR:-1}" ]; then
					pout_tag="ERROR"
				else return; fi
				;;
			--path)
				pout_tag="PATH"
				while [ "$#" -ge 2 ]; do
					case "$2" in
					--tail | --head)
						path_limit_start="${2#--}"
						path_limit="${path_limit:-1}"
						;;
					*)
						path_limit="${2:-"all"}"
						;;
					esac
					shift
				done
				break
				;;
			--) break ;;
			--*)
				if [ "$#" -eq 1 ]; then :; else
					shift
					for arg in "$@"; do
						pout_msg="${pout_msg:+"${pout_msg}${delimiter}"}${arg:-}"
					done
				fi
				break
				;;
			*)
				pout_msg="${pout_msg:+"${pout_msg}${delimiter}"}${1}"
				;;
			esac
			shift
		done

		#@ Build tag with flag and context
		pout_ctx="${pout_ctx:-"${ctx}"}"
		if [ -z "${pout_tag:-}" ]; then :; else
			case "$(to_lower "${pout_tag:-}")" in
			path) pout_ctx_tag="${pout_ctx}${ctx_sep}${pout_tag}" ;;
			*) pout_ctx_tag="${pout_tag}${ctx_sep}${pout_ctx}" ;;
			esac
		fi

		if [ -z "${pout_ctx_tag}" ]; then :; else
			pout_ctx_tag_head="${ctx_head:-"/> "}"
			pout_ctx_tag_tail="${ctx_tail:-" <\ "}"
			pout_ctx_tag="${pout_ctx_tag_head}${pout_ctx_tag}${pout_ctx_tag_tail}"
		fi

		#@ Replace the delimiter with a space
		pout_msg="$(
			printf "%b" "${pout_msg}" | tr "${delimiter}" " " || true
		)"
	}

	pout__execute() {
		#@ Print the message
		case "$(to_lower "${pout_tag:-}")" in
		test*)
			if [ "${verbosity:-0}" -lt "${VERBOSITY_TRACE:-5}" ]; then :; else
				printf "\n%b%b\n" "${pout_ctx_tag}" "${pout_msg}"
				eval "${pout_msg}"
			fi
			;;
		trace*)
			if [ "${verbosity:-0}" -lt "${VERBOSITY_TRACE:-5}" ]; then :; else
				printf "%b%b\n" "${pout_ctx_tag}" "${pout_msg}"
			fi
			;;
		debug*)
			if [ "${verbosity:-0}" -lt "${VERBOSITY_DEBUG:-4}" ]; then :; else
				printf "%b%b\n" "${pout_ctx_tag}" "${pout_msg}"
			fi
			;;
		info*)
			if [ "${verbosity:-0}" -lt "${VERBOSITY_INFO:-3}" ]; then :; else
				printf "%b%b\n" "${pout_ctx_tag}" "${pout_msg}"
			fi
			;;
		warn*)
			if [ "${verbosity:-0}" -lt "${VERBOSITY_WARN:-2}" ]; then :; else
				printf "%b%b\n" "${pout_ctx_tag}" "${pout_msg}"
			fi
			;;
		error*)
			if [ "${verbosity:-0}" -lt "${VERBOSITY_ERROR:-1}" ]; then :; else
				printf "%b%b\n" "${pout_ctx_tag}" "${pout_msg}"
			fi
			;;
		path*)
			#@ Print the tag
			printf "%b\n" "${pout_ctx_tag}"

			#@ Retrieve the paths from the PATH
			path="$(printf "%s" "${PATH}" | tr ':' '\n')"
			path_count="$(printf "%s" "${PATH}" | tr ':' '\n' | wc -l)"
			[ "${path_count:-0}" -gt 0 ] || {
				dots__pout --debug "[ERROR] /> ${ctx} <\ PATH is empty"
				return 1
			}

			#@ Limit the results, if necessary
			if [ "${path_limit:-}" -eq "${path_limit:-}" ] >/dev/null 2>&1; then
				#@ Calculate starting index based on limit
				case "${path_limit_start}" in
				tail)
					start_idx=$((path_count - path_limit + 1))
					[ "${start_idx}" -lt 1 ] && start_idx=1
					path="$(printf "%s" "${path}" | tail -n "${path_limit}")"
					;;
				*)
					start_idx=1
					path="$(printf "%s" "${path}" | head -n "${path_limit}")"
					;;
				esac
			else
				start_idx=1
			fi

			#@ Print the path
			i=$((start_idx - 1))
			for p in ${path}; do
				i=$((i + 1))
				printf "%3d %s %s\n" "${i}" "${ctx_sep}" "${p}"
			done

			#@ Cleanup
			unset path i p start_idx path_count path_limit path_limit_start
			;;
		print | *) printf "%b" "${pout_msg}" ;;
		esac

		#@ Cleanup
		IFS="${old_ifs}"
	}

	pout__main "$@"
}

dots__utilities() {

	pout_debug() {
		if [ "${verbosity:-0}" -lt "${verbosity_debug:-4}" ]; then
			return
		else
			printf "DEBUG /> %s /> %b\n" "${ctx:-dotsrc}" "$*"
		fi
	}

	to_upper() {
		printf "%s" "$*" | tr '[:lower:]' '[:upper:]'
	}

	to_lower() {
		printf "%s" "$*" | tr '[:upper:]' '[:lower:]'
	}

	quote() {
		os_type="${OS_TYPE:-"$(fetch_info --os)"}"

		while [ "$#" -gt 0 ]; do
			case "$1" in
			--single) quote__single "$2" ;;
			--escape) ;;
			--none) quote__remove "$2" ;;
			--double | *) ;;
			esac
			shift
		done

		quote__remove() {
			printf "%s" "$*" | tr -d "\"" | tr -d "\'"
		}

		quote__double() {
			esc="$(printf "%s" "$1" | sed 's/"/\\"/g')"
		}

		quote__single() {
			case "${os_type:-}" in
			windows)
				esc="$(printf "%s" "$1" | sed 's/"/\\"/g')"
				printf "\"%s\"" "${esc}"
				;;
			*)
				esc="$(printf "%s" "$1" | sed "s/'/'\\\\''/g")"
				printf "\'%s\'" "${esc}"
				;;
			esac
		}

		quote__escape() {
			:
		}
	}

	to_unquoted() {
		printf "%s" "$*" | tr -d "\"" | tr -d "\'"
	}

	resolve_path() {
		path="$1"

		if
			CMD_CYGPATH="${CMD_CYGPATH:-"$(
				command -v cygpath 2>/dev/null || true
			)"}" && [ -x "${CMD_CYGPATH:-}" ]
		then
			# "${CMD_CYGPATH}" --type mixed --absolute "${path}"
			path="$("${CMD_CYGPATH}" --type mixed --absolute "${path}")"
			printf "%s" "${path}"

		elif
			CMD_REALPATH="${CMD_REALPATH:-"$(
				command -v realpath 2>/dev/null || true
			)"}" && [ -x "${CMD_REALPATH:-}" ]
		then
			"${CMD_REALPATH}" "${path}"
		else
			dir_path="$(cd "$(dirname "${path}")" >/dev/null 2>&1 && pwd)"
			abs_path="${dir_path:?}/$(basename "${path}")"
			printf "%s\n" "${abs_path}"
		fi
	}

	exec_and_time() {
		. "${DOTS}/Bin/shellscript/benchmark/timit"
	}

	generate_uid() {
		proc="$$"
		secs="$(date +%s 2>/dev/null || true)"
		time="$(
			printf '%s' "${timestamp:-"${secs}"}" |
				sed -e 's/://g' -e 's/-//g' -e 's/ //g'
		)"
		uid="_${proc}_${time}"
		printf "%s" "${uid}"
	}

	manage_tempfile() {
		#@ Handle temp file operations with proper cleanup
		temp_action=""
		temp_file=""
		orig_file=""

		#@ Parse arguments
		while [ $# -gt 0 ]; do
			case "$1" in
			--file | --relative)
				temp_action="write"
				orig_file="$2"
				shift
				;;
			--write)
				temp_action="write"
				;;
			--read)
				temp_action="read"
				temp_file="$2"
				shift
				;;
			--cleanup)
				temp_action="cleanup"
				temp_file="$2"
				shift
				;;
			*)
				# orig_file="$1"
				;;
			esac
			shift
		done

		#@ Handle actions based on the provided flag
		case "${temp_action}" in
		write)
			if [ -n "${orig_file}" ]; then
				orig_file_dir="$(dirname "${orig_file}")"
				orig_file_name="$(basename "${orig_file}")"
				secs="$(date +%s 2>/dev/null || printf "%s" $$)"
				time="$(
					printf '%s' "${timestamp:-"${secs}"}" |
						sed -e 's/://g' -e 's/-//g' -e 's/ //g'
				)"
				uid="_tmp.${time}"
				temp_file="${orig_file_dir}/${uid}${orig_file_name}"
				orig_file_resolved="$(resolve_path "${orig_file}")"
				temp_file_resolved="$(resolve_path "${temp_file}")"

				dots__pout --ctx manage_tempfile \
					--trace "Creating temp file from ${orig_file_resolved} to ${temp_file_resolved}"

				if cp -i "${orig_file_resolved}" "${temp_file_resolved}" >/dev/null 2>&1; then
					dots__pout --ctx manage_tempfile \
						--trace "Created temp file relative to " \
						"'${orig_file_resolved}': ${temp_file_resolved}"

					#@ Return the clean path
					printf "%s" "${temp_file_resolved}"
					return 0
				else
					dots__pout --ctx manage_tempfile --error \
						"Failed to create temp file based on ${orig_file_resolved}"
					return 1
				fi
			else
				#@ Try various temp directories
				for _tmp_dir in "${TMPDIR:-/tmp}" /var/tmp /tmp; do
					{ [ -d "${_tmp_dir}" ] && [ -w "${_tmp_dir}" ]; } || continue
					temp_file="${_tmp_dir}/${ctx}_temp.$$.$(date +%s 2>/dev/null || printf "%s" $$)"

					#@ Ensure the temp file exists
					if touch "${temp_file}" 2>/dev/null; then
						dots__pout --ctx manage_tempfile --trace \
							"Created temp file: ${temp_file}"
						break
					else
						dots__pout --ctx manage_tempfile --trace \
							"Failed to create temp file: ${temp_file}"
						continue
					fi
				done
			fi

			#@ Return the temp file path
			if [ -f "${temp_file}" ] && [ -w "${temp_file}" ]; then

				#@ Restrict permissions if possible
				chmod 600 "${temp_file_resolved}" >/dev/null 2>&1

				printf "%s" "${temp_file}"
				return 0
			else
				return 1
			fi
			;;

		read)
			[ -f "${temp_file}" ] && cat "${temp_file}"
			return $?
			;;

		cleanup)
			[ -f "${temp_file}" ] && rm -f "${temp_file}" 2>/dev/null
			return $?
			;;

		*)
			return 1
			;;
		esac
	}

	format_shrc() {
		#@ Define the rc and temp file path
		file="${1:-"${DOTS_CACHE_RC:-}"}"
		file="$(resolve_path "${file}")"
		if [ -f "${file}" ]; then :; else
			dots__pout --error "File not found: ${file}"
			return 1
		fi

		#@ Define the temp file path and exit handler
		tmp_file="$(manage_tempfile --relative "${file}")"
		trap 'rm -f "${tmp_file}"' EXIT

		#@ Ensure if tmp_file exists
		if [ -f "${tmp_file}" ]; then :; else
			dots__pout --error "Temp file not created: ${tmp_file}"
			return 1
		fi

		#@ Extract header comments and blank lines at the top
		awk '
			/^[[:space:]]*#/ || /^[[:space:]]*$/ {
					if (!header_done) print
					next
			}
			!header_done {
					header_done=1
					exit
			}
		' "${file}" >"${tmp_file}"

		#@ Extract key-value lines (commented or uncommented) matching VAR=... export VAR
		#@ Prepend a marker for commented lines, strip leading '#' and whitespace for sorting
		grep -E '^[[:space:]]*#?[[:space:]]*[A-Za-z_][A-Za-z0-9_]*=.* export [A-Za-z_][A-Za-z0-9_]*' "${file}" |
			sed -e 's/^[[:space:]]*#\?[[:space:]]*//' -e 's/^/# /' |
			sort -t= -k1,1 |
			sed -e 's/^# //' >>"${tmp_file}"

		#@ Append any remaining lines after the sorted block
		awk '
				BEGIN {skip=0}
				/^[[:space:]]*#/ || /^[[:space:]]*$/ {
						if (!skip) next
				}
				/^[[:space:]]*#?[[:space:]]*[A-Za-z_][A-Za-z0-9_]*=.* export [A-Za-z_][A-Za-z0-9_]*$/ {
						if (!skip) skip=1
						next
				}
				skip { print }
			' "${file}" >>"${tmp_file}"

		#@ Format with shfmt if available
		if
			CMD_SHFMT="${CMD_SHFMT:-"$(
				command -v shfmt 2>/dev/null || true
			)"}" &&
				[ -x "${CMD_SHFMT:-}" ]
		then
			if
				"${CMD_SHFMT}" --write "${tmp_file}"
			then
				dots__pout --trace "Formatted file with shfmt: ${tmp_file}"
			else
				dots__pout --error "Failed to format file with shfmt: ${tmp_file}"
			fi
		else
			dots__pout --trace "shfmt not found, skipping formatting: ${tmp_file}"
		fi

		#@ Replace the original file with the updated version
		mv "${tmp_file}" "${file}"

		#@ Source the file if non-empty
		if [ -s "${file}" ]; then
			. "${file}"
		fi
	}

	set_cmd_env() {

		#@ Initialize garbage collection
		cleanup() {
			#@ Capture the exit code
			: "${exit_code:="${code:-"$?"}"}"

			#@ Handle error messages
			case "${exit_code}" in 0) ;;
			137)
				[ "${verbosity:-0}" -ge "${verbosity_error:-1}" ] &&
					printf "Operation interrupted by user\n"
				;;
			*)
				[ "${verbosity:-0}" -ge "${verbosity_error:-1}" ] &&
					printf "Operation terminated with exit code: %s\n" "${exit_code}"
				;;
			esac

			#@ Remove temporary file
			rm -f "${rc_file_tmp:-}" 2>/dev/null || true

			#@ Unset all local variables
			unset _action
			unset _arg
			unset _args
			unset _bin
			unset _bins
			unset _cmd
			unset _env
			unset _rc
			unset _var
			unset action
			unset add_to_cache
			unset arg_count
			unset cache_dir
			unset cache_rc
			unset update_required
			unset cmd_env
			unset cmd_inf
			unset cmd_val
			unset cmd_var
			unset env
			unset i
			unset ifs
			unset inf_via_cmd
			unset line_num
			unset rc_dir
			unset rc_file
			unset rc_file_tmp
			unset response
			unset sep
			unset cmd_val_new
			unset cmd_val_old
			unset val_via_bin
			unset val_via_cmd
			unset cmd_val_old
			unset var_name
			unset var_val
			unset var_value
			unset var_via_bin
			unset var_via_cmd
			unset cmd_val_new

			#@ Exit with the captured exit code
			return "${exit_code}"
		} && cleanup
		trap 'cleanup' EXIT INT TERM HUP

		#@ Initialize integral variables
		: "${ctx:="set_cmd_env"}"
		: "${code:=0}"
		: "${timestamp:="${timestamp:-"$(date '+%Y-%m-%d %H:%M:%S' 2>/dev/null || true)"}"}"
		: "${cache_rc:="${DOTS_CACHE_RC:-"${DOTS:-"${HOME:-}/.dots"}/.cache/.dotsrc"}"}"
		: "${sep:="${delimiter:-':'}"}"
		: "${add_to_cache:=true}"
		case "${reset_cache:-0}" in
		1 | true | yes | on | enable*) action="override" ;;
		*) action="shadow" ;; esac

		#@ Check arguments
		if [ "$#" -ge 1 ]; then :; else
			printf "Usage: %s [VARIABLE NAME] <COMMAND NAME> <BINARY PATH>\n" "${ctx}"
			code=1
			return
		fi

		#@ Parse named arguments
		while [ "$#" -ge 1 ]; do
			case "$1" in
			-e | --var)
				if [ -z "${2:-}" ]; then :; else
					shift
					_var="$1"
				fi
				;;
			-c | --cmd* | --command)
				if [ -z "${2:-}" ]; then :; else
					shift
					_cmd="$1"
				fi
				;;
			-p | --bin | --path)
				if [ -z "${1:-}" ]; then :; else
					shift
					_bins="${_bins:+${_bins}${sep}}$1"
				fi
				;;
			--export-file | --rc)
				if [ -z "${1:-}" ]; then :; else
					shift
					cache_rc="$1"
					add_to_cache=true
				fi
				;;
			--no-export | --no-rc)
				add_to_cache=false
				;;
			-f | --force | --raw) action="override" ;;
			*)
				_args="${_args:+${_args}${sep}}$1"
				;;
			esac
			shift
		done

		#@ Parse positional arguments
		#TODO: This is not quite working
		#TODO: If the only argument provided, if it;s obviously a path (maybe with /), then assume it's a binary
		#TODO: use the basename of the binary to check if it's in path
		if [ -z "${_args:-}" ] && [ -n "${_var:-}${_cmd:-}${_bins:-}" ]; then :; else
			# dots__pout --trace "Parsing positional arguments"
			#@ Split the arguments by the delimiter
			ifs="${IFS}"
			IFS="${sep}"

			#@ Count the number of arguments
			i=0
			for _ in ${_args}; do i=$((i + 1)); done
			_arg_count="${i}"

			#@ Iterate over the arguments
			i=0
			for _arg in ${_args}; do
				#@ Skip if the current argument is empty
				if [ -z "${_arg:-}" ]; then
					#@ Decrement the argument counter
					_arg_count=$((_arg_count - 1))
					continue
				else
					#@ Increment the counter
					i=$((i + 1))
					# dots__pout --trace "$(
					# 	printf "Argument %s or %s: %s\n" "${i}" "${_arg_count}" "${_arg}"
					# )"
				fi

				#@ Define the role of the current argument
				if [ -z "${_var:-"${_cmd:-}"}" ]; then
					#@ Assume the current argument is a command
					_cmd="$(
						printf "%s" "${_arg:-}" |
							sed -e "s/\"//g" -e "s/\'//g" |
							tr '[:space:]' '_' | tr '-' '_' | tr -s '_' || true
					)"

					#@ Set the variable name to CMD_<COMMAND NAME>
					var_via_cmd="$(
						printf "CMD_%s" "${_cmd:-}" |
							tr '[:lower:]' '[:upper:]' || true
					)"

					#@ Skip the rest of the loop
					continue
				else
					#@ Collect the remaining arguments as possible script paths
					_bin="${_bin:+${_bin}"${sep}"}${_arg}"
				fi
			done

			#@ Restore the original IFS
			IFS="${ifs}"
		fi

		case "${action:-}" in update | force) ;; *)
			#@ Load the cache file, if it exists
			if [ -s "${cache_rc}" ]; then
				. "${cache_rc}"
				#TODO: Check for the variable if it's already set and skip if so
			fi
			;;
		esac

		#@ Check for a provided variable name
		if [ -n "${_var:-}" ]; then
			# dots__pout --trace "Variable name provided: ${_var}"
			:
		fi

		#@ Check if any of the provided binary paths are executable
		if [ -z "${_bins:-}" ]; then :; else

			#@ Iterate over the binary paths for the first executable one
			for _bin in ${_bins}; do
				if [ -x "${_bin}" ]; then
					var_via_bin="$(
						#@ Set the variable name to CMD_<BIN_PATH_NAME>
						printf "CMD_%s" "$(basename "${_bin}")" |
							sed -e "s/\"//g" -e "s/\'//g" |
							tr '[:space:]' '_' |
							tr '-' '_' |
							tr -s '_' |
							tr '[:lower:]' '[:upper:]' ||
							true
					)"
					val_via_bin="${_bin}"
					# dots__pout --trace "Binary path provided: ${val_via_bin}"
					break
				else
					# dots__pout --trace "No executable binary was found of those provided"
					:
				fi
			done
		fi

		#@ Check for a command path from the provided command name
		if [ -n "${_cmd:-}" ]; then
			#@ Set the variable name to CMD_<COMMAND NAME>
			var_via_cmd="$(
				printf "CMD_%s" "${_cmd:-}" |
					sed -e "s/\"//g" -e "s/\'//g" |
					tr '[:space:]' '_' |
					tr '-' '_' |
					tr -s '_' |
					tr '[:lower:]' '[:upper:]' ||
					true
			)"
			#@ Retrieve the command information
			val_via_cmd="$(\type "${_cmd:-}" 2>/dev/null || true)"
			inf_via_cmd="$(printf '%s' "${val_via_cmd}" | head -n1 || true)"
			case "${inf_via_cmd:-"${val_via_cmd:-}"}" in
			*builtin | *keyword)
				# dots__pout --trace "$(printf "'%s'" "${inf_via_cmd}")"
				;;
			"${_cmd}"*"() ")
				# dots__pout --trace "$(
				# 	printf "'%s' refers to the following functions\n%s" \
				# 		"${_cmd}" "${val_via_cmd}"
				# )"
				;;
			*aliased*)
				# dots__pout --trace "$(
				# 	printf "'%s' is an alias of the command below" \
				# 		"${_cmd}" "${val_via_cmd}"
				# )"
				;;
			*/* | *\\*)
				#@ Remove the leading "<command> is " prefix to isolate the path
				val_via_cmd="${val_via_cmd#"${_cmd}" is }"
				if [ -f "${val_via_cmd:-}" ]; then
					if [ -x "${val_via_cmd:-}" ]; then
						# dots__pout --trace "$(
						# 	printf "'%s' is a system-wide executable\n" "${_cmd}"
						# )"
						:
					else
						# dots__pout --trace "$(
						# 	printf \
						# 		"'%s' is a file with inexecutable permissions\n" "${_cmd}"
						# )"
						code=1
						return
					fi
				else
					# dots__pout --trace "$(
					# 	printf "'%s' is not a file\n%s" "${_cmd}" "${val_via_cmd}"
					# )"
					code=1
					return
				fi
				;;
			*)
				#TODO: Handle other cases, this is a catch-all but not yet fail-safe
				;;
			esac
		fi

		#@ Normalize and set the command variable name and path
		cmd_var="${_var:-"${var_via_bin:-"${var_via_cmd:-}"}"}"
		if [ -n "${cmd_var:-}" ]; then
			cmd_val_old="$(eval "printf '%s' \"\$${cmd_var:-}"\")"
			cmd_val_new="${val_via_bin:-"${val_via_cmd:-}"}"
		else
			# dots__pout --error "$(printf "Variable name not defined\n")"
			code=1
			cleanup
			return
		fi

		#@ Update the command value
		case "${cmd_val_old:-""}" in
		"")
			if [ -n "${cmd_val_new:-}" ]; then
				# dots__pout --trace "${cmd_var} will be set to ${cmd_val_new}"
				cmd_val="${cmd_val_new:-}"
				update_required=true
			else
				# dots__pout --trace "No viable command or binary found related to '${_cmd}'"
				code=1
				cleanup
				return
			fi
			;;
		"${cmd_val_new:-}")
			# dots__pout --debug "${cmd_var} is already set to ${cmd_val_old}"
			cmd_val="${cmd_val_new:-}"
			;;
		*)
			case "${action:-}" in "override") ;; *)
				printf "The existing environment variable differs from the new one\n"
				printf "Old: %s\nNew: %s\nShould we proceed? [Y|n] => " \
					"${cmd_val_old}" "${cmd_val_new}"
				trap 'printf "CTRL + C\nOperation cancelled without any changes\n"; exit 137' INT
				read -r response
				case "${response:-Y}" in [yY]*)
					# dots__pout --trace "The existing environment variable will be replaced\n"
					cmd_val="${cmd_val_new:-}"
					update_required=true
					;;
				*)
					# dots__pout --trace "The existing environment variable will remain unchanged\n"
					cmd_val="${cmd_val_old:-}"
					;;
				esac
				;;
			esac
			;;
		esac

		#@ Set the command environment variable
		if [ -n "${cmd_var:-}" ] && [ -n "${cmd_val:-}" ]; then
			cmd_env="$(
				printf "%s=\"%s\" export %s" \
					"${cmd_var}" "${cmd_val}" "${cmd_var}"
			)"
		else
			# dots__pout --error "Requirements not met to establish the environment variable"
			code=1
			return
		fi

		#@ Write the command environment to the rc file if export is requested.
		case "${action:-}" in "override" | "export") update_required=true ;; *) ;; esac
		case "${add_to_cache:-}" in
		true | yes | on | 1)
			case "${update_required:-}" in true | yes | on | 1)
				#@ Write a full header to a file
				write_header() {
					_rc="$1"
					_action="${2:-Modified}"
					if {
						printf '%s\n' "#!/bin/sh"
						printf '%s\n' "# shellcheck enable=all"
						printf '# %s at: %s\n\n' "${_action}" "${timestamp}"
					} >"${_rc}"; then
						# dots__pout --trace "Created the rc file with the header: " "${_rc}"
						:
					else
						# dots__pout --error "Failed to write the header to the cache file"
						code=1
					fi
				}

				#@ Initialize variables
				rc_file="${cache_rc:-${DOTS}/cache/.dotsrc}"
				rc_file_tmp="${rc_file}.$}"
				rc_dir="$(dirname "${rc_file}")"

				#@ Set up cleanup trap for temporary files
				trap 'rm -f ${rc_file_tmp} 2>/dev/null || true' EXIT INT TERM

				#@ Add the command environment to the rc file
				case "${action:-}" in dry-run | simulate)
					# dots__pout --debug "$(
					# 	printf "Would add the following to '%s':\n%s\n" \
					# 		"${rc_file}" "${cmd_env}"
					# )"
					;;
				*)

					#@ Ensure the parent directory of the rc file exists
					if [ -d "${rc_dir}" ]; then
						if [ -w "${rc_dir}" ]; then
							# dots__pout --trace "Proceeding with cache directory: " "${rc_dir}"
							:
						else
							# dots__pout --error "Insufficient permissions for rc directory: " "${rc_dir}"
							code=1
							return
						fi
					else
						if mkdir -p "${rc_dir}"; then
							# dots__pout --trace "Created directory: " "${rc_dir}"
							:
						else
							# dots__pout --error "Failed to create directory: " "${rc_dir}"
							code=1
							return
						fi
					fi
					#@ Ensure the rc file exists and is writable
					if [ -e "${rc_file}" ]; then
						if [ -w "${rc_file}" ]; then
							# dots__pout --trace "Proceeding with cache file: " "${rc_file}"
							:
						else
							# dots__pout --error "Cache file exists but is not writable: " "${rc_file}"
							code=1
							return
						fi
					else
						#@ Try to create the rc file with the header
						write_header "${rc_file}" "Generated"
						if [ "${code}" -ne 0 ]; then return; fi
					fi

					if [ ! -f "${rc_file}" ] || [ ! -s "${rc_file}" ]; then
						write_header "${rc_file}" "Generated"
						if [ "${code}" -ne 0 ]; then return; fi
					elif ! grep -E '^# (Generated|Modified) at:' "${rc_file}" >/dev/null 2>&1; then
						write_header "${rc_file_tmp}" "Generated"
						if [ "${code}" -ne 0 ]; then return; fi

						#@ Append the contents of the rc file to the temp file
						cat "${rc_file}" >>"${rc_file_tmp}"

						#@ Replace the original rc file with the temp file
						mv "${rc_file_tmp}" "${rc_file}"
					else
						#@ Modify the timestamp line while preserving all other content
						sed "1,/^# \(Generated\|Modified\) at: .*/ s/^# \(Generated\|Modified\) at: .*/# Modified at: ${timestamp}/" "${rc_file}" >"${rc_file_tmp}"
						mv "${rc_file_tmp}" "${rc_file}"
					fi
					#@ Extract variable name and value from cmd_env
					var_name=$(printf "%s" "${cmd_env}" | cut -d'=' -f1)
					var_value=$(printf "%s" "${cmd_env}" | cut -d'=' -f2- | cut -d' ' -f1)

					#@ First check if the variable exists as an uncommented line
					if grep -Eq "^${var_name}=" "${rc_file:-}" || grep -Eq "^${var_name} " "${rc_file:-}"; then
						#@ Do nothing as the line already exists and is uncommented
						:
					elif grep -Eq "^#[ ]*${var_name}=${var_value}" "${rc_file:-}"; then
						#@ Uncomment the line if it has the same value (POSIX-compliant approach)
						sed "s|^#[ ]*\(${var_name}=${var_value}.*\)|\1|" "${rc_file:-}" >"${rc_file_tmp}"
						mv "${rc_file_tmp}" "${rc_file:-}"
					else
						#@ Check if there's a commented version with different value
						line_num=$(grep -n "^#[ ]*${var_name}=" "${rc_file:-}" | cut -d':' -f1 | head -1)

						if [ -n "${line_num}" ]; then
							#@ Add the new line right after the commented one (POSIX-compliant approach)
							{
								sed "${line_num}q" "${rc_file:-}"
								printf "%s\n" "${cmd_env}"
								sed "1,${line_num}d" "${rc_file:-}"
							} >"${rc_file_tmp}"
							mv "${rc_file_tmp}" "${rc_file:-}"
						else
							#@ If no version exists at all, append to the end
							printf "%s\n" "${cmd_env}" >>"${rc_file:-}"
						fi
					fi
					;;
				esac
				;;
			*)
				# dots__pout --trace "No changes were necessary to add to the rc file"
				;;
			esac
			;;
		*)
			# dots__pout --trace "Skipping because RC file updates are disabled"
			;;
		esac

		#@ Load the command environment
		if [ -n "${cmd_env:-}" ] && [ "${code}" -eq 0 ]; then
			eval "${cmd_env}" #? This works only if sourced
		fi
	}
}

dots__editor() {
	#@ Determine the path of the editor setter
	CMD_EDITOR="${CMD_EDITOR:-"$(
		command -v editor 2>/dev/null || true
	)"}"

	if [ -n "${CMD_EDITOR:-}" ]; then :; else
		return
	fi

	#@ Check if the editor setter is available and executable
	if [ -x "${CMD_EDITOR:-}" ]; then

		#@ Make the list of gui editors available globally
		if [ -n "${editors_gui}" ]; then
			EDITOR_GUI="${editors_gui}"
			export EDITOR_GUI
		fi

		#@ Make the list of tui editors available globally
		if [ -n "${editors_tui}" ]; then
			EDITOR_TUI="${editors_tui}"
			export EDITOR_TUI
		fi

		#@ Set the default editor
		EDITOR="$("${CMD_EDITOR}" --set 2>/dev/null || true)"

		#@ Return the default editor if it's executable
		if [ -x "${EDITOR:-}" ]; then
			dots__pout --trace "Default code editor set to: " "${EDITOR}"
			export EDITOR
		else
			dots__pout --error "Unable to set default code editor: " "${EDITOR}"
		fi
	fi
}

dots__cleanup() {
	unset ctx verbosity reset
}

dots__bin() {
	#@ Define configuration
	BIN_ROOT="${DOTS}/Bin"
	BIN_DEPTH=10
	BIN_IGNORE="review tmp temp archive"
	DOTS_PATH=""
	dir_count=0
	dir_count_added=0

	#@ Filter binary directories
	BIN_IGNORE_PATTERN=$(printf "%s" "${BIN_IGNORE}" | tr ' ' '|')
	BIN_DIRS="$(
		find "${BIN_ROOT}" -maxdepth "${BIN_DEPTH}" -type d |
			grep -v -E "/(${BIN_IGNORE_PATTERN})$" || true
	)"

	BIN_DIRS="$(printf "%s" "${BIN_DIRS}" | tr "\n" "${delimiter}")"
	oldIFS="${IFS}"
	IFS="${delimiter}"

	#@ Add all matching directories to PATH
	for dir in ${BIN_DIRS:-}; do
		dir_count=$((dir_count + 1))
		# echo "${dir_count}. ${dir}"
		# ls -ld "${dir}"

		#@ Skip if directory doesn't exist.
		[ -d "${dir}" ] || continue

		#@ Ensure all files are executable
		chmod +x -c "${dir}" || true
		# find "${dir}" -type f -print0 | xargs -0 chmod +x -c

		#@ Skip if already in PATH
		case ":${PATH}:" in
		*"${dir}"*)
			dots__pout --trace "Already in PATH: ${dir}"
			;;
		*)
			DOTS_PATH="${DOTS_PATH:+"${DOTS_PATH}:"}${dir}"
			dir_count_added=$((dir_count_added + 1))
			dots__pout --trace "Added in PATH: ${dir}"
			;;
		esac
	done
	IFS="${oldIFS}"

	if [ -z "${DOTS_PATH:-}" ]; then :; else
		# dots__pout --info "PATH updated with ${dir_count_added:-0} bin directories"
		PATH="${DOTS_PATH}:${PATH}"
	fi
}

dots__init_config() {
	init_git() {
		git config include.path "${GIT_CONFIG:-"${DOTS}/Configuration/git/main.gitconfig"}"
	}

	init_sh() {
		CMD_SH="$(command -v sh 2>/dev/null || true)"

		#@ Skip if the command or binary directory are missing
		if [ -x "${CMD_SH}" ]; then :; else return; fi
		if [ -d "${DOTS_BIN_SH:-"${DOTS}/Bin/shellscript"}" ]; then :; else return 1; fi

		#@ Set defaults and initialize counters
		depth_limit=4
		updated_count=0
		skipped_count=0
		new_path=""

		#@ Define cleanup function
		init_sh__cleanup() {
			unset updated_count skipped_count new_path depth_limit
		}

		#@ Set trap for proper cleanup
		trap init_sh__cleanup EXIT HUP INT TERM

		dots__pout --ctx "init_sh" --debug "Processing directories (depth: ${depth_limit})"

		#@ Process directories with limited recursion using pure shell
		process_dir() {
			dir="$1"
			current_depth="$2"

			#@ Check if we've reached depth limit
			[ "${current_depth}" -gt "${depth_limit}" ] && return

			#@ Check if directory is in excluded patterns
			case "${dir}" in
			*archive* | *review* | *temp* | *tmp*) return ;;
			*) ;;
			esac

			#@ Add directory to PATH if needed
			case ":${PATH}:" in
			*":${dir}:"*)
				skipped_count=$((skipped_count + 1))
				;;
			*)
				new_path="${new_path:+${new_path}:}${dir}"
				updated_count=$((updated_count + 1))
				;;
			esac

			#@ Only process subdirectories if we're not at max depth
			[ "${current_depth}" -eq "${depth_limit}" ] && return

			#@ Process subdirectories
			for subdir in "${dir}"/*; do
				[ -d "${subdir}" ] && process_dir "${subdir}" "$((current_depth + 1))"
			done
		}

		#@ Start recursive processing at depth 1
		process_dir "${DOTS_BIN_SH}" 3

		#@ Update PATH if we found new directories
		if [ -n "${new_path}" ]; then
			PATH="${new_path}:${PATH}"
			export PATH
		fi

		#@ Report the results
		dots__pout --ctx "init_sh" --info \
			"Processed binary directories - " \
			"Added: ${updated_count}" " | " \
			"Skipped: ${skipped_count}"

		#@ Cleanup
		init_sh__cleanup

		return 0
	}

	init_sh_OLD() {
		#@ Skip if the command or binary directory are missing
		if [ -x "${CMD_SH}" ]; then :; else return; fi
		if [ -d "${DOTS_BIN_SH}" ]; then :; else return; fi

		#@ Set defaults
		search_depth=5
		exclude_patterns="archive review temp tmp"
		exclude_patterns="$(printf "%s" "${exclude_patterns}" | sed 's/ /|/g')"
		bin_dirs="" bin_dir_count=0
		include="" include_count=0
		exclude="" exclude_count=0
		skipped="" skipped_count=0
		updated="" updated_count=0

		#@ Identify valid binary subdirectories.
		#TODO: we shouldn't have to perform find thrice
		bin_dirs="$(
			find "${DOTS_BIN_SH}" -maxdepth "${search_depth}" -type d |
				tr '\n' "${DELIMITER}"
		)"
		include="$(
			find "${DOTS_BIN_SH}" -maxdepth "${search_depth}" -type d |
				grep -Ev "${exclude_patterns}" | tr '\n' "${DELIMITER}"
		)"
		exclude="$(
			find "${DOTS_BIN_SH}" -maxdepth "${search_depth}" -type d |
				grep -E "${exclude_patterns}" | tr '\n' "${DELIMITER}"
		)"

		#@ Update the print delimiter
		old_ifs="${IFS}"
		IFS="${DELIMITER}"

		#@ Store the total number of directories in each category
		bin_dir_count="$(printf "%s" "${bin_dirs}" | tr "${DELIMITER}" "\n" | wc -l)"
		include_count="$(printf "%s" "${include}" | tr "${DELIMITER}" "\n" | wc -l)"
		exclude_count="$(printf "%s" "${exclude}" | tr "${DELIMITER}" "\n" | wc -l)"

		dots__pout --ctx "init_sh" --trace "bin_dir_count:" "${bin_dir_count}"
		dots__pout --ctx "init_sh" --trace "include_count:" "${include_count}"
		dots__pout --ctx "init_sh" --trace "exclude_count:" "${exclude_count}"

		# PATH="${PATH}:/c/Users/Administrator/.dots/Bin/shellscript/cmd"

		#@ Identify the directories to be added to the PATH
		i=0
		for bin_dir in ${include}; do
			i=$((i + 1))
			dots__pout --ctx "init_sh" --trace "${i}: ${bin_dir}"
			case "${PATH}" in
			"${bin_dir}"* | *":${bin_dir}:"* | ":${bin_dir}")
				skipped_count=$((skipped_count + 1))
				skipped="${skipped:+${skipped}${DELIMITER}}${bin_dir}"
				dots__pout --ctx "init_sh" --trace "Found in PATH:" "${i}>" "${bin_dir}"
				;;
			*)
				updated_count=$((updated_count + 1))
				updated="${updated:+${updated}${DELIMITER}}${bin_dir}"
				dots__pout --ctx "init_sh" --trace "Added to PATH:" "${i}>" "${bin_dir}"
				new_path="${new_path:+${new_path}":"}${bin_dir}"
				;;
			esac
		done

		printf "PATH:\n%s" "${new_path:-}"

		#@ Update the PATH variable, if necessary
		PATH="${new_path}:${PATH}" export PATH

		#@ Report the results
		dots__pout --ctx "init_sh" --info \
			"Processed" "${bin_dir_count}" "binary directories\n" \
			"Valid: ${include_count}" " | " \
			"Invalid: ${exclude_count}" " | " \
			"Skipped: ${skipped_count}" " | " \
			"Added: ${updated_count}"

		#@ Cleanup
		IFS="${old_ifs}"
		unset p b
	}

	init_bash() {
		#@ Skip if the command or binary directory are missing
		if [ -x "${CMD_BASH:-}" ]; then :; else return; fi
		if [ -d "${DOTS_BIN_BASH:-}" ]; then :; else return; fi

		#@ Check if the binary directory exists
		p="${PATH}"
		b="${DOTS_BIN_BASH}"
		#@ Update the PATH variable, if necessary
		case "${p}" in
		"${b}:"* | *":${b}:"* | ":${b}")
			dots__pout --debug "PATH includes: ${DOTS_BIN_BASH}"
			;;
		*)
			PATH="${DOTS_BIN_BASH}:${PATH}" export PATH
			dots__pout --debug "PATH updated to include: ${DOTS_BIN_BASH}"
			;;
		esac

		#@ Cleanup
		unset p b
	}

	init_nushell() {
		if [ -z "${CMD_NU}" ]; then return; else

			#@ Check if the nushell binary directory exists
			if [ -d "${DOTS_BIN_NU}" ]; then
				case "${PATH}" in
				"${DOTS_BIN_NU}:"* | *":${DOTS_BIN_NU}:"* | ":${DOTS_BIN_NU}") ;;
				*)
					unset "${DOTS_BIN_NU}"
					return
					;;
				esac
			fi
		fi

		#@ Prepend the nushell binary directory to the PATH
		if [ -z "${DOTS_BIN_NU}" ]; then :; else
			PATH="${DOTS_BIN_NU}:${PATH}" export PATH
			dots__pout --debug "Added to PATH: ${DOTS_BIN_SH}"
		fi
	}

	init_blesh() {
		CMD_BLESH="${HOME:-}/.local/share/blesh/ble.sh"
		if [ -f "${CMD_BLESH}" ]; then
			"${CMD_BLESH}" >/dev/null 2>&1
			dots__pout --debug "[INFO] /> dotsrc <\ Initialized Ble.sh"
		else
			dots__pout --debug "[ERROR] /> dotsrc <\ Missing Dependency: " "${CMD_BLESH}"
		fi
	}

	init_atuin() {
		CMD_ATUIN="$(command -v atuin 2>/dev/null || printf "")"
		if [ -x "${CMD_ATUIN}" ]; then
			eval "$(atuin init bash --disable-ctrl-r || true)"
			dots__pout --debug "[INFO] /> dotsrc <\ Initialized Atuin"
		else
			dots__pout --debug "[ERROR] /> dotsrc <\ Missing Dependency: " "${CMD_ATUIN}"
		fi
	}

	init_starship() {
		#@ Retrieve the path to the starship binary
		CMD_STARSHIP="$(command -v starship 2>/dev/null || true)"

		if [ -x "${CMD_STARSHIP:-}" ]; then
			export CMD_STARSHIP

			#@ Skip if starship already initiated
			if [ -z "${STARSHIP_START_TIME:-}" ]; then :; else
				dots__pout --debug "[INFO] /> dotsrc <\ Starship already initiated"
				return 0
			fi

			#@ Use the custom configuration file if it exists
			starship_config="${DOTS}/Configuration/starship/config.toml"
			if [ ! -f "${starship_config}" ]; then :; else
				STARSHIP_CONFIG="${starship_config}"
				export STARSHIP_CONFIG
			fi

			#@ Initialize starship
			eval "$(starship init bash || true)"
			dots__pout --debug "[INFO] /> dotsrc <\ Initialized Starship"
		else
			dots__pout --debug "[ERROR] /> dotsrc <\ Missing Dependency: starship"
		fi
	}

	init_oh_my_posh() {
		if [ -x "${CMD_OMP:-}" ]; then
			eval "$("${CMD_OMP:?}" --set "${1:-}" || true)"
		else return; fi
		# CMD_OMP="$(
		# 	command -v omp 2>/dev/null ||
		# 		printf "%s" "${DOTS}/Bin/shellscript/packages/alias/omp"
		# )"

		# if [ -x "${CMD_OMP:-}" ]; then
		# 	eval "$(omp --set "${1:-}" || true)"
		# fi
	}

	init_fastfetch() {
		#@ Retrieve the path to the fastfetch binary
		CMD_FASTFETCH="$(command -v starship 2>/dev/null || true)"

		if [ -x "${CMD_FASTFETCH}" ]; then
			export CMD_FASTFETCH

			#@ Check if the starship configuration file exists
			fastfetch_config="${DOTS}/Configuration/fastfetch/config.jsonc"

			#@ Initialize fastfetch
			if [ -f "${fastfetch_config}" ]; then
				FASTFETCH_CONFIG="${fastfetch_config}"
				export FASTFETCH_CONFIG
				fetch() { fastfetch --config "${FASTFETCH_CONFIG}"; }
			else
				fetch() { fastfetch; }
			fi
			fetch

			dots__pout --debug "[INFO] /> dotsrc <\ Initialized Fastfetch"
		else
			dots__pout --debug "[ERROR] /> dotsrc <\ Missing Dependency: " "${CMD_FASTFETCH}"
		fi
	}

	init_projects() {
		rc=".dotsrc"
		[ -f "${PRJ_CC}/${rc}" ] && . "${PRJ_CC}/${rc}"
		[ -f "${PRJ_CRAOLE}/${rc}" ] && . "${PRJ_CRAOLE}/${rc}"
		[ -f "${PRJ_CRAOLE}/${rc}" ] && . "${PRJ_CRAOLE}/${rc}"
		unset rc
	}
}

dots__environment() {
	#@ Set output control variables
	DELIMITER="${DELIMITER:-"$(printf "\037")"}" export DELIMITER
	LANG="$(locale -uU || printf "en_US.UTF-8")" export LANG
	VERBOSITY="${verbosity:-"${VERBOSITY:-3}"}"
	VERBOSITY_QUIET="${verbosity_quiet:-"${VERBOSITY_QUIET:-0}"}"
	VERBOSITY_ERROR="${verbosity_error:-"${VERBOSITY_ERROR:-1}"}"
	VERBOSITY_WARN="${verbosity_warn:-"${VERBOSITY_WARN:-2}"}"
	VERBOSITY_INFO="${verbosity_info:-"${VERBOSITY_INFO:-3}"}"
	VERBOSITY_DEBUG="${verbosity_debug:-"${VERBOSITY_DEBUG:-4}"}"
	VERBOSITY_TRACE="${verbosity_trace:-"${VERBOSITY_TRACE:-5}"}"
	export VERBOSITY VERBOSITY_QUIET VERBOSITY_ERROR VERBOSITY_WARN VERBOSITY_INFO VERBOSITY_DEBUG VERBOSITY_TRACE

	#@ Ensure the integral DOTS variable are set
	DOTS="${DOTS:-"${HOME:-}/.dots"}"
	if [ -d "${DOTS}" ]; then
		alias ".dots"='cd "${DOTS}"'
		alias "cd.dots"='cd "${DOTS}"'
		alias "ed.dots"='ed "${DOTS}"'
	else
		dots__pout --debug "DOTS directory is inaccessible:" "${DOTS}"
		return 1
	fi
	RC="${RC:-".dotsrc"}"
	DOTS_RC="${DOTS_RC:-"${DOTS}/${RC}"}"
	DOTS_CACHE="${DOTS}/.cache"
	DOTS_CACHE_RC="${DOTS_CACHE}/${RC}"
	DOTS_CACHE_RC_TEMP="${DOTS_CACHE}/$(generate_uid)${RC}"
	export DOTS DOTS_RC DOTS_CACHE DOTS_CACHE_RC DOTS_CACHE_RC_TEMP

	#@ Load top-level directory variables
	DOTS_BIN="${DOTS_BIN:-"${DOTS}/Bin"}"
	if [ -d "${DOTS_BIN}" ]; then
		#@ Define exports
		alias "cd.dots_bin"='cd "${DOTS_BIN}"'
		alias "ed.dots_bin"='ed "${DOTS_BIN}"'

		#@ Load the rc if it exists
		DOTS_BIN_RC="${DOTS_BIN_RC:-"${DOTS_BIN}/${RC}"}"
		if [ -f "${DOTS_BIN_RC}" ]; then
			. "${DOTS_BIN_RC}"
		else
			dots__pout --debug "Missing run command file:" "${DOTS_BIN_RC}"
		fi
	else
		dots__pout --debug "Inaccessible directory:" "${DOTS_BIN}"
	fi

	#@ Update the cache
	if [ -s "${DOTS_CACHE_RC}" ]; then . "${DOTS_CACHE_RC}"; fi
	[ -n "${CMD_BACON}" ] || set_cmd_env --cmd bacon
	[ -n "${CMD_BASH}" ] || set_cmd_env --cmd bash
	[ -n "${CMD_BAT}" ] || set_cmd_env --cmd bat
	[ -n "${CMD_CARGO}" ] || set_cmd_env --cmd cargo
	[ -n "${CMD_CODE_INSIDERS}" ] || set_cmd_env --cmd code-insiders
	[ -n "${CMD_CODE}" ] || set_cmd_env --cmd code
	[ -n "${CMD_CYGPATH}" ] || set_cmd_env --cmd cygpath
	[ -n "${CMD_EDITOR}" ] || set_cmd_env --cmd editor --bin "${DOTS}/Bin/shellscript/packages/defaults/editor"
	[ -n "${CMD_EZA}" ] || set_cmd_env --cmd eza
	[ -n "${CMD_FD}" ] || set_cmd_env --cmd fd
	[ -n "${CMD_FISH}" ] || set_cmd_env --cmd fish
	[ -n "${CMD_FYLS}" ] || set_cmd_env --cmd fyls --bin "${DOTS}/Bin/shellscript/environment/fyls"
	[ -n "${CMD_GITUI}" ] || set_cmd_env --cmd gitui
	[ -n "${CMD_GIT}" ] || set_cmd_env --cmd git
	[ -n "${CMD_HX}" ] || set_cmd_env --cmd hx
	[ -n "${CMD_LSD}" ] || set_cmd_env --cmd lsd
	[ -n "${CMD_NANO}" ] || set_cmd_env --cmd nano
	[ -n "${CMD_NIX}" ] || set_cmd_env --cmd nix
	[ -n "${CMD_NIXOS_VERSION}" ] || set_cmd_env --cmd nixos-version
	[ -n "${CMD_NVIM}" ] || set_cmd_env --cmd nvim
	[ -n "${CMD_NU}" ] || set_cmd_env --cmd nu
	[ -n "${CMD_OH_MY_POSH}" ] || set_cmd_env --cmd oh-my-posh
	[ -n "${CMD_OMP}" ] || set_cmd_env --cmd omp --bin "${DOTS}/Bin/shellscript/packages/alias/omp"
	[ -n "${CMD_PAGER}" ] || set_cmd_env --cmd pager --bin "${DOTS}/Bin/shellscript/output/pager"
	[ -n "${CMD_PERL}" ] || set_cmd_env --cmd perl
	[ -n "${CMD_POUT_REPEAT}" ] || set_cmd_env --cmd pout-repeat --bin "${DOTS}/Bin/shellscript/output/pout-repeat"
	[ -n "${CMD_POUT}" ] || set_cmd_env --cmd pout --bin "${DOTS}/Bin/shellscript/output/pout"
	[ -n "${CMD_POWERSHELL}" ] || set_cmd_env --cmd powershell
	[ -n "${CMD_PWSH}" ] || set_cmd_env --cmd pwsh
	[ -n "${CMD_RG}" ] || set_cmd_env --cmd rg
	[ -n "${CMD_RUSTC}" ] || set_cmd_env --cmd rustc
	[ -n "${CMD_SHFMT}" ] || set_cmd_env --cmd shfmt
	[ -n "${CMD_STARSHIP}" ] || set_cmd_env --cmd starship
	[ -n "${CMD_STRALT}" ] || set_cmd_env --cmd stralt --bin "${DOTS}/Bin/shellscript/output/stralt"
	[ -n "${CMD_TOKEI}" ] || set_cmd_env --cmd tokei
	[ -n "${CMD_TOPGRADE}" ] || set_cmd_env --cmd topgrade
	[ -n "${CMD_TR}" ] || set_cmd_env --cmd tr
	[ -n "${CMD_VALIDATE}" ] || set_cmd_env --cmd validate --bin "${DOTS}/Bin/shellscript/validators/validate"
	[ -n "${CMD_WATCH}" ] || set_cmd_env --cmd watch
	[ -n "${CMD_WATSH}" ] || set_cmd_env --cmd watsh --bin "${DOTS}/Bin/shellscript/project/watsh"
	[ -n "${CMD_WGET}" ] || set_cmd_env --cmd wget
	[ -n "${CMD_ZED}" ] || set_cmd_env --cmd zed
	[ -n "${CMD_ZEDITOR}" ] || set_cmd_env --cmd zeditor
	[ -n "${CMD_ZIG}" ] || set_cmd_env --cmd zig
	[ -n "${CMD_ZSH}" ] || set_cmd_env --cmd zsh
	if [ -f "${DOTS_CACHE_RC}" ] && [ -s "${DOTS_CACHE_RC}" ]; then
		#@ Format and sorth the variables in the cache rc
		# format_shrc "${DOTS_CACHE_RC}" #TODO: Fix the tempfile managemennt for this

		#@ Reload the cache rc
		. "${DOTS_CACHE_RC}"
		# dots__pout --trace "Cache reloaded."
	else
		# dots__pout --warn "Cache not found."
		:
	fi

	#@ Set the editor
	dots__editor
	# if
	# 	CMD_EDITOR="${CMD_EDITOR:-"$(
	# 		command -v editor 2>/dev/null || true
	# 	)"}" && [ -x "${CMD_EDITOR}" ]
	# then
	# 	EDITOR_GUI="${editors_gui}"
	# 	EDITOR_TUI="${editors_tui}"
	# 	export EDITOR_GUI EDITOR_TUI

	# 	EDITOR="$("${CMD_EDITOR}" --set)"
	# 	export EDITOR
	# fi

	# #| Projects
	# if [ -n "${PRJ}" ]; then
	# 	dotsenv --dir PRJ "${PRJ}"
	# elif [ -d "${HOME}/Projects" ]; then
	# 	dotsenv --dir PRJ "${HOME}/Projects"
	# elif
	# 	: ||
	# 		[ -d "${HOME}/Documents/GitLab" ] ||
	# 		[ -d "${HOME}/Documents/Gitlab" ] ||
	# 		[ -d "${HOME}/Documents/gitlab" ] ||
	# 		[ -d "${HOME}/Documents/GitHub" ] ||
	# 		[ -d "${HOME}/Documents/Github" ] ||
	# 		[ -d "${HOME}/Documents/github" ]
	# then
	# 	dotsenv --dir PRJ "${HOME}/Documents"
	# else
	# 	dotsenv --dir PRJ "${DOTS}/../Projects"
	# fi
}

main "$@"
