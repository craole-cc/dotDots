#!/bin/sh
# shellcheck enable=all

main() {
  set_defaults
  init_dots
  # init_blesh
  # init_atuin
  init_starship
  init_fastfetch
  init_scripts
  init_tests
}

set_defaults() {
  debug=0
  home="${HOME:-/home/craole}"
  DELIMITER="$(printf "\037")"
  export DELIMITER
}

pout_debug() {
  msg=""
  case "${debug:-}" in
  1 | true | on)
    for arg in "$@"; do
      msg="${msg:+${msg} }${arg:-}"
    done
    ;;
  *) ;;
  esac

  if [ -n "${msg}" ]; then
    printf "%b\n" "${msg}"
  else
    :
  fi
}

init_dots() {
  [ -d "${DOTS:-}" ] || {
    printf "[ERROR] /> dotsrc < The path to DOTS directory must be set.\n" >&2
    return 1
  }

  pathman="${DOTS:-/home/craole/.dots}/Bin/shellscript/environment/pathman"
  if [ -x "${pathman}" ]; then
    # ${pathman}
    pout_debug "[INFO] /> dotsrc <\ Initialized dotDots"
  else
    pout_debug "[ERROR] /> dotsrc <\ Missing Dependency: " "${pathman}"
  fi
}

init_blesh() {
  CMD_BLESH="${home}/.local/share/blesh/ble.sh"
  if [ -f "${CMD_BLESH}" ]; then
    "${CMD_BLESH}" >/dev/null 2>&1
    pout_debug "[INFO] /> dotsrc <\ Initialized Ble.sh"
  else
    pout_debug "[ERROR] /> dotsrc <\ Missing Dependency: " "${CMD_BLESH}"
  fi
}

init_atuin() {
  CMD_ATUIN="$(command -v atuin 2>/dev/null || printf "")"
  if [ -n "${CMD_ATUIN}" ]; then
    eval "$(atuin init bash --disable-ctrl-r || true)"
    pout_debug "[INFO] /> dotsrc <\ Initialized Atuin"
  else
    pout_debug "[ERROR] /> dotsrc <\ Missing Dependency: " "${CMD_ATUIN}"
  fi
}

init_starship() {
  #@ Retrieve the path to the starship binary
  CMD_STARSHIP="$(command -v starship 2>/dev/null || printf "")"
  export CMD_STARSHIP

  if [ -n "${CMD_STARSHIP}" ]; then

    #@ Check if the starship configuration file exists
    starship_config="${DOTS}/Configuration/starship/config.toml"
    [ -f "${starship_config}" ] && {
      #@ Set the STARSHIP_CONFIG environment variable
      STARSHIP_CONFIG="${starship_config}"
      export STARSHIP_CONFIG
    }

    #@ Initialize starship
    eval "$(starship init bash || true)"
    pout_debug "[INFO] /> dotsrc <\ Initialized Starship"
  else
    pout_debug "[ERROR] /> dotsrc <\ Missing Dependency: " "${CMD_STARSHIP}"
  fi
}

init_fastfetch() {
  #@ Retrieve the path to the fastfetch binary
  CMD_FASTFETCH="$(command -v fastfetch 2>/dev/null || printf "")"
  export CMD_FASTFETCH

  if [ -n "${CMD_FASTFETCH}" ]; then

    #@ Check if the starship configuration file exists
    fastfetch_config="${DOTS}/Configuration/fastfetch/config.jsonc"

    #@ Initialize fastfetch
    if [ -f "${fastfetch_config}" ]; then
      #@ Set the FASTFETCH_CONFIG environment variable
      FASTFETCH_CONFIG="${fastfetch_config}"
      export FASTFETCH_CONFIG
      fetch() { fastfetch --config "${FASTFETCH_CONFIG}"; }
    else
      fetch() { fastfetch; }
    fi
    fetch

    pout_debug "[INFO] /> dotsrc <\ Initialized Fastfetch"
  else
    pout_debug "[ERROR] /> dotsrc <\ Missing Dependency: " "${CMD_FASTFETCH}"
  fi
}

init_scripts() {
  os() {
    if command -v nix >/dev/null 2>&1; then
      printf "nix"
    else
      case "$(uname | tr '[:upper:]' '[:lower:]')" in
      *linux*) printf "linux" ;;
      *msys*) printf "windows" ;;
      *darwin*) printf "macos" ;;
      *) printf "unknown" ;;
      esac
    fi
  }

  to_upper() {
    printf "%s" "$*" | tr '[:lower:]' '[:upper:]'
  }

  swap_delimiter() {
    #@ Set defaults
    _sep="${delimiter:-"${DELIMITER:- }"}"
    _old="${_sep}" _new=" "
    _str="" _res=""

    #@ Parse arguments
    while [ "$#" -gt 0 ]; do
      case "$1" in
      --old*)
        _old="$2"
        shift
        ;;
      --new*)
        _new="$2"
        shift
        ;;
      --str*)
        _str="${_str:+${_str}${_sep}}$2"
        shift
        ;;
      *) _str="${_str:+${_str}${_sep}}$1" ;;
      esac
      shift
    done

    #@ Build the string with the old delimiter
    old_ifs="${IFS}"
    IFS="${_sep}"
    for val in ${_str:-}; do
      _res="${_res:+${_res}${_old}}${val}"
    done
    IFS="${old_ifs}"

    #@ Output
    printf "%s" "${_res}" | tr "${_old}" "${_new}"
  }

  dev() {
    case "$(os)" in
    nix) nix develop "$@" ;;
    *)
      cwd="$(pwd -P || "${PWD:-.}")"
      arg="${*:-"${cwd}"}"
      cmd="${VISUAL:-${EDITOR:-code}} ${arg}"
      eval "${cmd}" 2>/dev/null || {
        pout_debug "[ERROR] /> dotsrc <\ Failed to run ${cmd}"
        return 1
      }
      pout_debug "[INFO] /> dotsrc <\ Opened ${arg} in ${VISUAL:-${EDITOR:-code}}"
      ;;
    esac
  }

  enviro_OLD() {
    #@ Set defaults
    ctx="enviro"
    delimiter="${DELIMITER:-"$(printf "\037")"}"
    separator="_"
    OLDIFS="${IFS}" IFS="${delimiter}"
    dirs=""
    type="env" shell="bash"
    prefix="" suffix="" key="" val="" env=""
    result=""

    #@ Parse arguments
    while [ "$#" -gt 0 ]; do
      case "$1" in
      --set | --name | --var)
        if [ -n "$2" ]; then
          key="${key:+${key}${delimiter}}$2"
        else
          pout_debug "[ERROR] /> ${ctx} <\ Missing argument for" "$1"
          exit 1
        fi
        shift
        ;;
      --prefix)
        if [ -n "$2" ]; then
          prefix="${prefix:+${prefix}${delimiter}}$2"
        else
          pout_debug "[ERROR] /> ${ctx} <\ Missing argument for" "$1"
          exit 1
        fi
        shift
        ;;
      --suffix)
        if [ -n "$2" ]; then
          suffix="${suffix:+${suffix}${delimiter}}$2"
        else
          pout_debug "[ERROR] /> ${ctx} <\ Missing argument for" "$1"
          exit 1
        fi
        shift
        ;;
      --sh | --shell)
        if [ -n "$2" ]; then
          shell="$2"
        else
          pout_debug "[ERROR] /> ${ctx} <\ Missing argument for" "$1"
          exit 1
        fi
        shift
        ;;
      --sep*)
        if [ -n "$2" ]; then
          separator="$2"
        else
          pout_debug "[ERROR] /> ${ctx} <\ Missing argument for" "$1"
          exit 1
        fi
        shift
        ;;
      --cmd*)
        type="cmd"
        if [ -n "$2" ]; then
          val="${val:+${val}${delimiter}}$2"
          shift
        else
          pout_debug "[ERROR] /> ${ctx} <\ Missing argument for --cmd"
          exit 1
        fi
        ;;
      --env*)
        type="env"
        if [ -n "$2" ]; then
          val="${val:+${val}${delimiter}}$2"
          shift
        else
          pout_debug "[ERROR] /> ${ctx} <\ Missing argument for --env"
          exit 1
        fi
        ;;
      --dir*)
        type="dir"
        if [ -n "$2" ]; then
          val="${val:+${val}${delimiter}}$2"
        else
          pout_debug "[ERROR] /> ${ctx} <\ Missing directory name"
        fi
        shift
        ;;
      --file*)
        type="file"
        if [ -n "$2" ]; then
          val="${val:+${val}${delimiter}}$2"
        else
          pout_debug "[ERROR] /> ${ctx} <\ Missing directory name"
        fi
        shift
        ;;
      *)
        val="${val:+${val}${delimiter}}$1"
        ;;
      esac
      shift
    done

    #@ Define prefix
    if [ -z "${prefix:-}" ]; then :; else
      prefix="$(to_upper "${prefix}")"
      prefix="$(
        swap_delimiter "${prefix}" \
          --old "${delimiter}" --new "${separator}"
      )"
      pout_debug "/> ${ctx} <\ prefix:" "${prefix}"
    fi

    #@ Define suffix
    if [ -z "${suffix:-}" ]; then :; else
      suffix="$(to_upper "${suffix}")"
      suffix="$(
        swap_delimiter "${suffix}" \
          --old "${delimiter}" --new "${separator}"
      )"
      pout_debug "/> ${ctx} <\ suffix:" "${suffix}"
    fi

    #@ Define variable name
    if [ -z "${key:-}" ]; then :; else
      key="$(to_upper "${key}")"
      key="$(
        swap_delimiter "${key}" \
          --old "${delimiter}" --new "${separator}"
      )"
      pout_debug "/> ${ctx} <\ key:" "${key}"
    fi

    #@ Define variable name
    if [ -z "${key:-}" ]; then :; else

      #@ Add prefix
      if [ -z "${prefix:-}" ]; then :; else
        key="${prefix}${separator}${key}"
      fi

      #@ Add suffix
      if [ -z "${suffix:-}" ]; then :; else
        key="${suffix}${separator}${key}"
      fi
      pout_debug "/> ${ctx} <\ key:" "${key}"
    fi

    #@ Define environment pair
    for _val in ${val}; do
      case "${type:-"env"}" in
      cmd)
        #@ Initialize variables
        cmd="${_val}" cmd_key="" cmd_val="" cmd_env=""

        #@ Define the key in uppercase, prefixed with "CMD_"
        cmd_key="$(to_upper "CMD_${cmd}")"
        pout_debug "/> ${ctx} <\ [${cmd}] CMD_KEY: ${cmd_key}"

        #@ Retrieve the path, otherwise return empty string
        cmd_val="$(command -v "${cmd}" 2>/dev/null || printf '')"
        if [ -f "${cmd_val}" ]; then :; else
          case "${cmd_val}" in
          *alias*)
            pout_debug "/> ${ctx} <\ [${cmd}] CMD_ALIAS: ${cmd_val}"
            unalias "${cmd}" &&
              cmd_val="$(command -v "${cmd}" 2>/dev/null || printf '')"
            ;;
          *function*)
            #TODO: Add support for functions
            ;;
          *) ;;
          esac
        fi
        pout_debug "/> ${ctx} <\ [${cmd}] CMD_VAL: ${cmd_val}"

        #@ Create the export statement
        case "${shell:-"bash"}" in
        sh | bash | zsh)
          cmd_env="$(
            printf "%s=%s\nexport %s" \
              "${cmd_key}" "${cmd_val}" "${cmd_key}"
          )"
          ;;
        fish*)
          cmd_env="$(
            printf "set -x %s %s" \
              "${cmd_key}" "${cmd_val}"
          )"
          ;;
        nu*)
          cmd_env="$(
            printf "let-env %s = \"%s\"" \
              "${cmd_key}" "${cmd_val}"
          )"
          ;;
        pwsh | powershell)
          cmd_env="$(
            printf "\$env:%s = \"%s\"" \
              "${cmd_key}" "${cmd_val}"
          )"
          ;;
        *)
          pout_debug "[ERROR] /> ${ctx} <\ Unsupported shell: ${shell}"
          exit 1
          ;;
        esac

        #@ Update the environment list
        env="${env:+${env}${delimiter}}${cmd_env}"
        ;;
      dir)
        #@ Initialize variables
        dir="${_val}" dir_key="" dir_expr=""

        #@ Check if directory exists
        if [ -d "${dir}" ]; then
          pout_debug "/> ${ctx} <\ Directory found: ${dir}"

          #@ Define the key in uppercase, prefixed with "DIR_"
          if [ -z "${key:-}" ]; then
            dir_base="$(basename "${dir}")"
            dir_key="$(to_upper "DIR_${dir_base}")"
          else
            dir_key="${key}"
          fi

          pout_debug "/> ${ctx} <\ [${dir}] DIR_KEY: ${dir_key}"

          #@ Create the export statement
          case "${shell:-"bash"}" in
          sh | bash | zsh)
            dir_expr="$(
              printf "%s=%s\nexport %s" \
                "${dir_key}" "${dir}" "${dir_key}"
            )"
            ;;
          fish | f*)
            dir_expr="$(
              printf "set -x %s %s" \
                "${dir_key}" "${dir}"
            )"
            ;;
          nu*)
            dir_expr="$(
              printf "let-env %s = \"%s\"" \
                "${dir_key}" "${dir}"
            )"
            ;;
          pwsh | powershell | power*)
            dir_expr="$(
              printf "\$env:%s = \"%s\"" \
                "${dir_key}" "${dir}"
            )"
            ;;
          *)
            pout_debug "[ERROR] /> ${ctx} <\ Unsupported shell: ${shell}"
            exit 1
            ;;
          esac

          #@ Update the environment list
          env="${env:+${env}${delimiter}}${dir_expr}"
          dirs="${dirs:+${dirs}${delimiter}}${dir}"
        else
          pout_debug "/> ${ctx} <\ Directory not found: ${dir}"
        fi
        ;;
      env | *)
        #@ Initialize variables
        env_key="" env_val="${_val}" env_expr=""

        #@ Parse key=value format
        if [ -z "${key:-}" ]; then
          case "${_val}" in
          *=*)
            env_key="${_val%%=*}"
            env_val="${_val#*=}"
            ;;
          *)
            env_key="$(to_upper "${_val}")"
            env_val="$(eval printf "%s" "\${${_val}:-}")"
            ;;
          esac
        else
          env_key="${key}"
        fi

        pout_debug "/> ${ctx} <\ [${env_key}] ENV_VAL: ${env_val}"

        #@ Create the export statement
        case "${shell:-"bash"}" in
        sh | bash | zsh)
          env_expr="$(
            printf "%s=%s\nexport %s" \
              "${env_key}" "${env_val}" "${env_key}"
          )"
          ;;
        fish | f*)
          env_expr="$(
            printf "set -x %s %s" \
              "${env_key}" "${env_val}"
          )"
          ;;
        nu*)
          env_expr="$(
            printf "let-env %s = \"%s\"" \
              "${env_key}" "${env_val}"
          )"
          ;;
        pwsh | powershell | power*)
          env_expr="$(
            printf "\$env:%s = \"%s\"" \
              "${env_key}" "${env_val}"
          )"
          ;;
        *)
          pout_debug "[ERROR] /> ${ctx} <\ Unsupported shell: ${shell}"
          exit 1
          ;;
        esac

        #@ Update the environment list
        env="${env:+${env}${delimiter}}${env_expr}"
        ;;
      esac
    done

    #@ Return the environment list
    result="$(
      for pair in ${env}; do
        printf "%s\n" "${pair}"
        case "${shell:-"bash"}" in
        sh | bash | zsh) printf "\n" ;; *) ;; esac
      done
    )"
    printf "%s" "${result}"
    IFS="${OLDIFS}"
  }
  prj_rust() {
    # possible_dirs=(
    #   "${PRJ_RUST}"
    #   "${PROJECTS}/rust"
    #   "${HOME}/Projects/rust"
    #   "${HOME}/projects/Code/Rust"
    #   "${HOME}/projects/Code/rust"
    # )
    :
  }

  enviro() {
    #@ Set defaults
    ctx="enviro" _ctx=""
    delimiter="${DELIMITER:-"$(printf "\037")"}"
    separator="_"
    OLDIFS="${IFS}" IFS="${delimiter}"

    #@ Default settings
    action="get"
    shell="$(basename "${SHELL:-"posix"}")"
    order="$(printf "abs|cmd|env" | tr "|" "${delimiter}")"
    focus="" _focus=""
    key=""
    val=""
    arg=""
    result=""

    #@ Parse arguments
    while [ "$#" -ge 1 ]; do
      case "$1" in
      --action)
        if [ -n "$2" ]; then
          action="$2"
          shift
        else
          pout_debug "[WARN] /> ${ctx} <\ Missing argument for '$1'. Using default: ${action}"
        fi
        ;;
      --get | --set | --unset | --check)
        action="${1#--}"
        ;;
      --shell)
        if [ -n "$2" ]; then
          shell="$2"
          shift
        else
          pout_debug "[WARN] /> ${ctx} <\ Missing argument for '$1'. Using default: ${action}"
        fi
        ;;
      --sh | --bash | --zsh | --pwsh | --fish | --nu* | --powershell)
        shell="${1#--}"
        ;;
      --type | --focus | --order)
        _ctx="$1"

        #@ Move to first argument after the flag
        shift

        #@ Store all arguments until next flag
        while [ "$#" -ge 1 ]; do
          case "$1" in
          --*) break ;;
          *) _focus="${_focus:+${_focus}${delimiter}}$1" ;;
          esac
          shift
        done

        #@ Process stored focus args
        IFS="${delimiter}"
        for item in ${_focus}; do
          case "${item}" in
          cmd | env | dir | path | file | link | abs)
            focus="${focus:+${focus}${delimiter}}${item}"
            ;;
          *)
            #@ Prepend invalid args to maintain original order
            set -- "${item}" "$@"
            ;;
          esac
        done

        #@ Cleanup
        IFS="${OLDIFS}"
        _focus=""

        #@ Skip the final shift
        continue
        ;;
      --cmd | "cmd" | command | --env | env | --dir | dir | --path | path | --file | file | --link | link | --abs | abs)
        echo "LOOSE --> $1"
        focus="${focus:+${focus}${delimiter}}${1#--}"
        ;;
      --key*)
        if [ -n "$2" ]; then
          key="$2"
          shift 2
        else
          pout_debug "[ERROR] /> ${ctx} <\ Missing argument for $1"
          return 1
        fi
        ;;
      --val*)
        if [ -n "$2" ]; then
          val="$2"
          shift 2
        else
          pout_debug "[ERROR] /> ${ctx} <\ Missing argument for $1"
          return 1
        fi
        ;;
      *)
                args="${args:+${args}${delimiter}}$1"
        ;;
      esac
      shift
    done

if [ -z "${args}" ];then : ; else
  for arg in "${args}"; do
    case "${action}" in
      set)
        if [ -z "${key}" ]; then
          key="${arg}"
        else
          val="${val:+${val}${delimiter}}${arg}"
        fi
      ;;
      check)
      ;;
      get|unset|*)
        if [ -n "${val}" ];then
         key="${key:+${key}${delimiter}}${val}"
         key="${key:+${key}${delimiter}}${arg}"
        else
         key="${key:+${key}${delimiter}}${arg}"
        fi
       ;; 
      

    pout_debug "/> ${ctx} <\  FOCUS:" "$(
      printf "%s" "${focus:-"${order}"}" |
        tr "${delimiter}" "|" || true
    )"
    pout_debug "/> ${ctx} <\  SHELL:" "${shell}"
    pout_debug "/> ${ctx} <\ ACTION:" "${action}"
    pout_debug "/> ${ctx} <\    KEY:" "${key:-}"
    pout_debug "/> ${ctx} <\    VAL:" "$(
      printf "\"%s\"" "${val}" |
        tr "${delimiter}" " " || true
    )"

    return

    # @Extract the shell basename without path
    shell_name="$(basename "${shell}")"
    case "${shell_name}" in
    *fish*) shell_type="fish" ;;
    *nu*) shell_type="nushell" ;;
    *pwsh | *powershell) shell_type="powershell" ;;
    *sh | *) shell_type="posix" ;;
    esac

    pout_debug "/> ${ctx} <\ Action: ${action}, Shell: ${shell_name} (${shell_type}), Type: ${type}, Key: ${key}, Val: ${val}"

    # Process based on action
    case "${action:-get}" in
    set)
      # Set requires a key and value
      if [ -z "${key}" ]; then
        pout_debug "[ERROR] /> ${ctx} <\ Missing key for --set"
        return 1
      fi

      # If type is not specified but val is empty, try to autodetect
      if [ -z "${type}" ] && [ -z "${val}" ]; then
        # Try to find what key refers to
        if command -v "${key}" >/dev/null 2>&1; then
          type="cmd"
          val="$(command -v "${key}")"
        elif [ -d "${key}" ]; then
          type="dir"
          val="${key}"
        elif [ -f "${key}" ]; then
          type="file"
          val="${key}"
        elif [ -L "${key}" ]; then
          type="link"
          val="${key}"
        else
          # Default to env
          type="env"
          val="${key}"
        fi
      fi

      # Default val to key if not specified
      if [ -z "${val}" ]; then
        val="${key}"
      fi

      # Generate appropriate export syntax
      case "${type}" in
      cmd)
        # For commands, prefix with CMD_
        cmd_path="$(command -v "${key}" 2>/dev/null || echo "${val}")"
        env_key="CMD_$(echo "${key}" | tr '[:lower:]' '[:upper:]')"

        case "${shell_type}" in
        posix)
          result="${env_key}=${cmd_path}\nexport ${env_key}"
          ;;
        fish)
          result="set -x ${env_key} ${cmd_path}"
          ;;
        nushell)
          result="let-env ${env_key} = \"${cmd_path}\""
          ;;
        powershell)
          result="\$env:${env_key} = \"${cmd_path}\""
          ;;
        esac
        ;;

      dir)
        # For directories, prefix with DIR_ if no custom key
        if [ "${key}" = "${val}" ]; then
          # Auto-generate key from directory name
          dir_name="$(basename "${key}")"
          env_key="DIR_$(echo "${dir_name}" | tr '[:lower:]' '[:upper:]')"
        else
          env_key="$(echo "${key}" | tr '[:lower:]' '[:upper:]')"
        fi

        case "${shell_type}" in
        posix)
          result="${env_key}=${val}\nexport ${env_key}"
          ;;
        fish)
          result="set -x ${env_key} ${val}"
          ;;
        nushell)
          result="let-env ${env_key} = \"${val}\""
          ;;
        powershell)
          result="\$env:${env_key} = \"${val}\""
          ;;
        esac
        ;;

      file)
        # For files, prefix with FILE_ if no custom key
        if [ "${key}" = "${val}" ]; then
          # Auto-generate key from file name
          file_name="$(basename "${key}")"
          env_key="FILE_$(echo "${file_name}" | tr '[:lower:]' '[:upper:]')"
        else
          env_key="$(echo "${key}" | tr '[:lower:]' '[:upper:]')"
        fi

        case "${shell_type}" in
        posix)
          result="${env_key}=${val}\nexport ${env_key}"
          ;;
        fish)
          result="set -x ${env_key} ${val}"
          ;;
        nushell)
          result="let-env ${env_key} = \"${val}\""
          ;;
        powershell)
          result="\$env:${env_key} = \"${val}\""
          ;;
        esac
        ;;

      path)
        # Add to PATH variable
        case "${shell_type}" in
        posix)
          result="PATH=${val}:\${PATH}\nexport PATH"
          ;;
        fish)
          result="set -x PATH ${val} \$PATH"
          ;;
        nushell)
          result="let-env PATH = \"${val}:\${env.PATH}\""
          ;;
        powershell)
          result="\$env:Path = \"${val};\$env:Path\""
          ;;
        esac
        ;;

      env | *)
        # For environment variables, use as is
        env_key="$(echo "${key}" | tr '[:lower:]' '[:upper:]')"

        case "${shell_type}" in
        posix)
          result="${env_key}=${val}\nexport ${env_key}"
          ;;
        fish)
          result="set -x ${env_key} ${val}"
          ;;
        nushell)
          result="let-env ${env_key} = \"${val}\""
          ;;
        powershell)
          result="\$env:${env_key} = \"${val}\""
          ;;
        esac
        ;;
      esac
      ;;

    unset)
      # Unset requires a key
      if [ -z "${key}" ]; then
        pout_debug "[ERROR] /> ${ctx} <\ Missing key for --unset"
        return 1
      fi

      # If type is cmd, prepend CMD_
      if [ "${type}" = "cmd" ]; then
        env_key="CMD_$(echo "${key}" | tr '[:lower:]' '[:upper:]')"
      elif [ "${type}" = "dir" ]; then
        if [[ "${key}" != DIR_* ]]; then
          env_key="DIR_$(echo "${key}" | tr '[:lower:]' '[:upper:]')"
        else
          env_key="$(echo "${key}" | tr '[:lower:]' '[:upper:]')"
        fi
      elif [ "${type}" = "file" ]; then
        if [[ "${key}" != FILE_* ]]; then
          env_key="FILE_$(echo "${key}" | tr '[:lower:]' '[:upper:]')"
        else
          env_key="$(echo "${key}" | tr '[:lower:]' '[:upper:]')"
        fi
      else
        env_key="$(echo "${key}" | tr '[:lower:]' '[:upper:]')"
      fi

      # Generate unset command
      case "${shell_type}" in
      posix)
        result="unset ${env_key}"
        ;;
      fish)
        result="set -e ${env_key}"
        ;;
      nushell)
        result="hide-env ${env_key}"
        ;;
      powershell)
        result="Remove-Item env:${env_key} -ErrorAction SilentlyContinue"
        ;;
      esac
      ;;

    check)
      # Check if a path exists in PATH
      if [ -z "${key}" ]; then
        pout_debug "[ERROR] /> ${ctx} <\ Missing path to check"
        return 1
      fi

      # Get PATH and check
      path_found="0"
      IFS=":"
      for path_item in ${PATH}; do
        IFS="${OLDIFS}"
        if [ "${path_item}" = "${key}" ]; then
          path_found="1"
          break
        fi
      done
      IFS="${OLDIFS}"

      if [ "${path_found}" = "1" ]; then
        result="true"
      else
        result="false"
      fi
      ;;
    get | *)
      # If no type specified, try to detect using search_order
      if [ -z "${type}" ]; then
        IFS=":"
        for search_type in ${search_order}; do
          IFS="${OLDIFS}"
          pout_debug "/> ${ctx} <\ Trying type: ${search_type} for ${key}"

          case "${search_type}" in
          cmd)
            # Check if it's a command
            cmd_val="$(command -v "${key}" 2>/dev/null || true)"
            if [ -n "${cmd_val}" ]; then
              result="${cmd_val}"
              break
            fi
            ;;
          abs)
            # Check if it's an absolute path
            if [ -e "${key}" ]; then
              if [ -d "${key}" ]; then
                # It's a directory
                result="${key}"
                break
              elif [ -f "${key}" ]; then
                # It's a file
                result="${key}"
                break
              elif [ -L "${key}" ]; then
                # It's a symlink
                result="${key}"
                break
              fi
            fi
            ;;
          env)
            # Check if it's an environment variable - try uppercase first
            env_key_upper="$(echo "${key}" | tr '[:lower:]' '[:upper:]')"
            env_val="$(eval echo "\${${env_key_upper}:-}")"

            if [ -n "${env_val}" ]; then
              result="${env_val}"
              break
            fi

            # Try original case
            env_val="$(eval echo "\${${key}:-}")"
            if [ -n "${env_val}" ]; then
              result="${env_val}"
              break
            fi
            ;;
          path)
            # TODO: use grep or case to check for the exact val in PATH. Remember it could be at the front, back or in the middle so user ":" appropriately
            ;;
          *)
            #TODO: We need search type order as well, so if the search type is not defined the default order should be cmd:env:abs. Ourder can also be user-defined.
            ;;
          esac
        done
        IFS="${OLDIFS}"
      else
        # Specific type was requested
        case "${type}" in
        cmd)
          result="$(command -v "${key}" 2>/dev/null || true)"
          ;;
        dir)
          if [ -d "${key}" ]; then
            result="${key}"
          else
            result=""
          fi
          ;;
        file)
          if [ -f "${key}" ]; then
            result="${key}"
          else
            result=""
          fi
          ;;
        link)
          if [ -L "${key}" ]; then
            result="${key}"
          else
            result=""
          fi
          ;;
        abs)
          # Return absolute path
          if [ -e "${key}" ]; then
            # Get absolute path
            if command -v realpath >/dev/null 2>&1; then
              result="$(realpath "${key}")"
            elif command -v readlink >/dev/null 2>&1; then
              result="$(readlink -f "${key}" 2>/dev/null || echo "${key}")"
            else
              # Fallback to a more portable but less reliable method
              current_dir="$(pwd)"
              cd "$(dirname "${key}")" 2>/dev/null || {
                result="${key}"
                break
              }
              dir_path="$(pwd)"
              cd "${current_dir}" || true
              result="${dir_path}/$(basename "${key}")"
            fi
          else
            result=""
          fi
          ;;
        path)
          # Return PATH with each entry on a new line
          if [ -z "${key}" ] || [ "${key}" = "PATH" ] || [ "${key}" = "Path" ]; then
            case "${shell_type}" in
            posix)
              result="$(echo "${PATH}" | tr ':' '\n')"
              ;;
            fish)
              result="$(echo "${PATH}" | tr ':' '\n')"
              ;;
            nushell)
              result="$(echo "${PATH}" | tr ':' '\n')"
              ;;
            powershell)
              # For PowerShell, we can't easily get the PATH here
              # Just echo the POSIX PATH as a fallback
              result="$(echo "${PATH}" | tr ':' '\n')"
              ;;
            esac
          else
            # Get a specific path variable
            env_val="$(eval echo "\${${key}:-}")"
            result="$(echo "${env_val}" | tr ':' '\n')"
          fi
          ;;
        env)
          # First try uppercase
          env_key_upper="$(echo "${key}" | tr '[:lower:]' '[:upper:]')"
          env_val="$(eval echo "\${${env_key_upper}:-}")"

          if [ -n "${env_val}" ]; then
            result="${env_val}"
          else
            # Try original case
            env_val="$(eval echo "\${${key}:-}")"
            result="${env_val}"
          fi
          ;;
        esac
      fi
      ;;
    esac

    # Output the result
    printf "%s" "${result}"
    return 0
  }

}

init_tests() {
  debug=1
  pout_debug "/> dotsrc <\ Tests initialized"

  enviro pop --type abs --bash cmd jaja --type cmd --nu lol
  # enviro --type env abs --val pop cmd --shell nu link --file --action set path --key lock

  # enviro --cmd "cmd" command --type cmd file --env env --dir dir --path path --file file --link link --abs abs
  return
  # Get command path (all these do the same)
  enviro --cmd fd
  echo
  enviro --get fd
  echo
  enviro fd
  echo

  # Get environment variable
  enviro USER
  echo
  enviro --env USER

  printf "\n\n%s\n" "SET COMMANDS"
  enviro --cmd fd --shell bah --set
  echo
  enviro --cmd fd --shell pwsh --set
  echo
  enviro --cmd fd --shell fish --set
  echo
  enviro --cmd fd --shell nushell --set
  # Output: CMD_FD=/path/to/fd\nexport CMD_FD

  printf "\n\n%s\n" "GET VARIABLES"
  #TODO: This should generate the necessary get command for the appropriate shell. It's not just about returning the command. Remember if the --shell flag is set it means it will be used in that situation
  enviro --get --env USER --shell pwsh
  # Output: C:\Users\Administrator

  printf "\n\n%s\n" "SET VARIABLES"
  # Set custom env var in PowerShell
  enviro --env myvar --set craole --shell pwsh
  # Output: $env:USER = "craole"

  printf "\n\n%s\n" "UPDATE PATH"
  enviro --path --set /usr/local/bin

  printf "\n\n%s\n" "CHECK PATH"
  enviro --path --check /usr/local/bin

  printf "\n\n%s\n" "GET ABS PATH"
  enviro --abs ~/.config
  echo
  enviro --abs "${HOME}"

  printf "\n\n%s\n" "SET DIR"
  enviro --dir /usr/local --set LOCAL_DIR
  echo

  # enviro --cmd rustc cargo fd pop ls --shell pwsh
  # enviro --cmd fd --shell bash
  # enviro --env USER --shell pwsh
  # enviro \
  #   "${HOME}/Projects/Code/Rust" \
  #   --name rust \
  #   "${PRJ_RUST:-}" \
  #   --prefix prj \
  #   --prefix for \
  #   --prefix work \
  #   "${HOME}/Projects/rust"

  # swap_delimiter pop lock --str lol --old "|" --new "*"
  pout_debug "\n/> dotsrc <\ Tests completed"
}

main "$@"
