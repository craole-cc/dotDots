#!/bin/sh
# shellcheck enable=all
# shellcheck disable=SC1090
# set -e #TODO: this needs to be temporary, just for clean coding

main() {
	dots__settings
	dots__utilities
	dots__environment

	# dots__init_scripts #TODO: Move all to bin
	# dots__init_bin
	# echo "EDITOR: ${EDITOR}"
	# return
	# dots__set_global_env

	# dots__init_config

	# init_oh_my_posh config
	# init_starship

	# dots__init_scripts
	# dots__init_aliases
	# fetch_info
	# init_scripts
	# init_sh

	# init_bash
	# return
	# init_nushell
	# init_blesh
	# init_atuin
	# init_starship
	# init_fastfetch
	# init_tests || init_fastfetch || true
	# dots__pout --path --tail
	# dots__pout --path --head 50
	# echo "${PATH}" | tr ':' '\n'
	# pout_PATH
	# "${CMD_PATHMAN}"
	# if [ "${verbosity:-0}" -lt "${verbosity_trace:-5}" ]; then :; else
	# 	printf "DOTS Loaded.\n"
	# fi
	fastfetch
}

dots__settings() {
	ctx="DOTS"
	timestamp="$(date '+%Y-%m-%d %H:%M')"
	ctx_sep=" | "
	ctx_head=">>- "
	ctx_tail=" ->> "
	verbosity=4 #? 0=quiet, 1=error, 2=warn, 3=info, 4=debug, 5=trace
	verbosity_quiet=0
	verbosity_error=1
	verbosity_warn=2
	verbosity_info=3
	verbosity_debug=4
	verbosity_trace=5
	delimiter="${DELIMITER:-"$(printf "\037")"}"
	# debug=1
	# reset_cache=1 #? 0=no, 1=yes
	editors_tui="hx:nvim:nano"
	editors_gui="code:zeditor:zed.exe"
}

dots__utilities() {

	manage_tempfile() {
		#@ Handle temp file operations with proper cleanup
		temp_action=""
		temp_file=""

		#@ Parse arguments
		while [ $# -gt 0 ]; do
			case "$1" in
			--write)
				temp_action="write"
				shift
				;;
			--read)
				temp_action="read"
				temp_file="$2"
				shift 2
				;;
			--cleanup)
				temp_action="cleanup"
				temp_file="$2"
				shift 2
				;;
			*) shift ;;
			esac
		done

		#@ Handle actions based on the provided flag
		case "${temp_action}" in
		write)
			#@ Try various temp directories
			for _tmp_dir in "${TMPDIR:-/tmp}" /var/tmp /tmp; do
				{ [ -d "${_tmp_dir}" ] && [ -w "${_tmp_dir}" ]; } || continue
				temp_file="${_tmp_dir}/${ctx}_temp.$$.$(/bin/date +%s 2>/dev/null || printf "%s" $$)"
				touch "${temp_file}" 2>/dev/null || continue

				#@ Restrict permissions if possible
				case "${OS_TYPE:-}" in
				*linux* | *darwin* | *bsd*) chmod 600 "${temp_file}" 2>/dev/null || true ;;
				*) ;;
				esac

				[ -f "${temp_file}" ] && [ -w "${temp_file}" ] && break
			done

			#@ Return the temp file path
			printf "%s" "${temp_file}"
			return 0
			;;

		read)
			[ -f "${temp_file}" ] && cat "${temp_file}"
			return $?
			;;

		cleanup)
			[ -f "${temp_file}" ] && rm -f "${temp_file}" 2>/dev/null
			return $?
			;;

		*)
			return 1
			;;
		esac
	}

	dots__pout() {
		pout__main() {
			pout__set_local_env
			pout__parse_arguments "$@"
			pout__execute
		}

		pout__set_local_env() {
			ctx_sep="${ctx_sep:-"-|-"}"
			pout_tag=""
			pout_ctx=""
			pout_msg=""
			pout_ctx_tag=""
			path_limit=""
			path_limit_start="head"
			path=""
			delimiter="${DELIMITER:-"$(printf "\037")"}"
			old_ifs="${IFS}"
			IFS="${delimiter}"
		}

		pout__parse_arguments() {
			while [ "$#" -ge 1 ]; do
				case "$1" in
				--ctx)
					pout_ctx="$2"
					shift
					;;
				--trace) pout_tag="TRACE" ;;
				--test) pout_tag="TEST" ;;
				--debug) pout_tag="DEBUG" ;;
				--info) pout_tag="INFO" ;;
				--warn) pout_tag="WARN" ;;
				--err* | --fatal | --fail*]) pout_tag="ERROR" ;;
				--path)
					pout_tag="PATH"
					while [ "$#" -ge 2 ]; do
						case "$2" in
						--tail | --head)
							path_limit_start="${2#--}"
							path_limit="${path_limit:-1}"
							;;
						*)
							path_limit="${2:-"all"}"
							;;
						esac
						shift
					done
					break
					;;
				--) break ;;
				--*)
					if [ "$#" -eq 1 ]; then :; else
						shift
						for arg in "$@"; do
							pout_msg="${pout_msg:+"${pout_msg}${delimiter}"}${arg:-}"
						done
					fi
					break
					;;
				*)
					pout_msg="${pout_msg:+"${pout_msg}${delimiter}"}${1}"
					;;
				esac
				shift
			done

			#@ Build tag with flag and context
			pout_ctx="${pout_ctx:-"${ctx}"}"
			if [ -z "${pout_tag:-}" ]; then :; else
				case "$(to_lower "${pout_tag:-}")" in
				path) pout_ctx_tag="${pout_ctx}${ctx_sep}${pout_tag}" ;;
				*) pout_ctx_tag="${pout_tag}${ctx_sep}${pout_ctx}" ;;
				esac
			fi

			if [ -z "${pout_ctx_tag}" ]; then :; else
				pout_ctx_tag_head="${ctx_head:-"/> "}"
				pout_ctx_tag_tail="${ctx_tail:-" <\ "}"
				pout_ctx_tag="${pout_ctx_tag_head}${pout_ctx_tag}${pout_ctx_tag_tail}"
			fi

			#@ Replace the delimiter with a space
			pout_msg="$(
				printf "%b" "${pout_msg}" | tr "${delimiter}" " " || true
			)"
		}

		pout__execute() {
			#@ Print the message
			case "$(to_lower "${pout_tag:-}")" in
			test*)
				if [ "${verbosity:-0}" -lt "${VERBOSITY_TRACE:-5}" ]; then :; else
					printf "\n%b%b\n" "${pout_ctx_tag}" "${pout_msg}"
					eval "${pout_msg}"
				fi
				;;
			trace*)
				if [ "${verbosity:-0}" -lt "${VERBOSITY_TRACE:-5}" ]; then :; else
					printf "%b%b\n" "${pout_ctx_tag}" "${pout_msg}"
				fi
				;;
			debug*)
				if [ "${verbosity:-0}" -lt "${VERBOSITY_DEBUG:-4}" ]; then :; else
					printf "%b%b\n" "${pout_ctx_tag}" "${pout_msg}"
				fi
				;;
			info*)
				if [ "${verbosity:-0}" -lt "${VERBOSITY_INFO:-3}" ]; then :; else
					printf "%b%b\n" "${pout_ctx_tag}" "${pout_msg}"
				fi
				;;
			warn*)
				if [ "${verbosity:-0}" -lt "${VERBOSITY_WARN:-2}" ]; then :; else
					printf "%b%b\n" "${pout_ctx_tag}" "${pout_msg}"
				fi
				;;
			error*)
				if [ "${verbosity:-0}" -lt "${VERBOSITY_ERROR:-1}" ]; then :; else
					printf "%b%b\n" "${pout_ctx_tag}" "${pout_msg}"
				fi
				;;
			path*)
				#@ Print the tag
				printf "%b\n" "${pout_ctx_tag}"

				#@ Retrieve the paths from the PATH
				path="$(printf "%s" "${PATH}" | tr ':' '\n')"
				path_count="$(printf "%s" "${PATH}" | tr ':' '\n' | wc -l)"
				[ "${path_count:-0}" -gt 0 ] || {
					dots__pout --debug "[ERROR] /> ${ctx} <\ PATH is empty"
					return 1
				}

				#@ Limit the results, if necessary
				if [ "${path_limit:-}" -eq "${path_limit:-}" ] >/dev/null 2>&1; then
					#@ Calculate starting index based on limit
					case "${path_limit_start}" in
					tail)
						start_idx=$((path_count - path_limit + 1))
						[ "${start_idx}" -lt 1 ] && start_idx=1
						path="$(printf "%s" "${path}" | tail -n "${path_limit}")"
						;;
					*)
						start_idx=1
						path="$(printf "%s" "${path}" | head -n "${path_limit}")"
						;;
					esac
				else
					start_idx=1
				fi

				#@ Print the path
				i=$((start_idx - 1))
				for p in ${path}; do
					i=$((i + 1))
					printf "%3d %s %s\n" "${i}" "${ctx_sep}" "${p}"
				done

				#@ Cleanup
				unset path i p start_idx path_count path_limit path_limit_start
				;;
			print | *) printf "%b" "${pout_msg}" ;;
			esac

			#@ Cleanup
			IFS="${old_ifs}"
		}

		pout__main "$@"
	}

	pout_debug() {
		if [ "${verbosity:-0}" -lt "${verbosity_debug:-4}" ]; then
			return
		else
			printf "DEBUG /> %s /> %b\n" "${ctx:-dotsrc}" "$*"
		fi
	}

	to_upper() {
		printf "%s" "$*" | tr '[:lower:]' '[:upper:]'
	}

	to_lower() {
		printf "%s" "$*" | tr '[:upper:]' '[:lower:]'
	}

	quote() {
		os_type="${OS_TYPE:-"$(fetch_info --os)"}"

		while [ "$#" -gt 0 ]; do
			case "$1" in
			--single) quote__single "$2" ;;
			--escape) ;;
			--none) quote__remove "$2" ;;
			--double | *) ;;
			esac
			shift
		done

		quote__remove() {
			printf "%s" "$*" | tr -d "\"" | tr -d "\'"
		}

		quote__double() {
			esc="$(printf "%s" "$1" | sed 's/"/\\"/g')"
		}

		quote__single() {
			case "${os_type:-}" in
			windows)
				esc="$(printf "%s" "$1" | sed 's/"/\\"/g')"
				printf "\"%s\"" "${esc}"
				;;
			*)
				esc="$(printf "%s" "$1" | sed "s/'/'\\\\''/g")"
				printf "\'%s\'" "${esc}"
				;;
			esac
		}

		quote__escape() {
			:
		}
	}

	to_unquoted() {
		printf "%s" "$*" | tr -d "\"" | tr -d "\'"
	}

	format_rc() {
		file="${1:-"${DOTS_CACHE_RC:-}"}"

		#@ Format with shfmt if available
		CMD_SHFMT="${CMD_SHFMT:-"$(command -v shfmt 2>/dev/null || true)"}"
		if [ -x "${CMD_SHFMT:-}" ]; then
			"${CMD_SHFMT}" --write "${file}"
		fi

		if [ -f "${file}" ]; then
			tmpfile="$(manage_tempfile --write)"
			trap 'rm -f "${tmpfile}"' EXIT

			#@ Extract header comments and blank lines at the top
			awk '
				/^[[:space:]]*#/ || /^[[:space:]]*$/ {
						if (!header_done) print
						next
				}
				!header_done {
						header_done=1
						exit
				}
			' "${file}" >"${tmpfile}"

			#@ Extract key-value lines (commented or uncommented) matching VAR=... export VAR
			#@ Prepend a marker for commented lines, strip leading '#' and whitespace for sorting
			grep -E '^[[:space:]]*#?[[:space:]]*[A-Za-z_][A-Za-z0-9_]*=.* export [A-Za-z_][A-Za-z0-9_]*' "${file}" |
				sed -e 's/^[[:space:]]*#\?[[:space:]]*//' -e 's/^/# /' |
				sort -t= -k1,1 |
				sed -e 's/^# //' >>"${tmpfile}"

			#@ Append any remaining lines after the sorted block
			awk '
				BEGIN {skip=0}
				/^[[:space:]]*#/ || /^[[:space:]]*$/ {
						if (!skip) next
				}
				/^[[:space:]]*#?[[:space:]]*[A-Za-z_][A-Za-z0-9_]*=.* export [A-Za-z_][A-Za-z0-9_]*$/ {
						if (!skip) skip=1
						next
				}
				skip { print }
			' "${file}" >>"${tmpfile}"

			#@ Replace the original file with the updated version
			mv "${tmpfile}" "${file}"
		fi

		#@ Source the file if non-empty
		if [ -s "${file}" ]; then
			. "${file}"
		fi
	}

	set_cmd_env() {
		#@ Unset all variables used in set_cmd_env
		unset _var _env env _cmd cmd_val cmd_var cmd_env _bin _bins _args add_to_cache cache_rc sep action
		unset ifs i arg_count _arg var_val cmd_inf cache_dir response
		unset var_via_bin var_via_cmd val_via_bin val_via_cmd val_via_var change_triggered

		#@ Initialize variables
		ctx="set_cmd_env"
		code=0
		timestamp="${timestamp:-"$(date '+%Y-%m-%d %H:%M:%S')"}"
		cache_rc="${DOTS_CACHE_RC:-"${DOTS:-"${HOME:-}/.dots"}/.cache/.dotsrc"}"
		sep="${delimiter:-':'}"
		add_to_cache=true
		case "${reset_cache:-0}" in
		1 | true | yes | on | enable*) action="override" ;;
		*) action="shadow" ;; esac

		#@ Check arguments
		if [ "$#" -ge 1 ]; then :; else
			printf "Usage: %s [VARIABLE NAME] <COMMAND NAME> <BINARY PATH>\n" "${ctx}"
			code=1
			return
		fi

		#@ Parse named arguments
		while [ "$#" -ge 1 ]; do
			case "$1" in
			-e | --var)
				if [ -z "${2:-}" ]; then :; else
					shift
					_var="$1"
				fi
				;;
			-c | --cmd* | --command)
				if [ -z "${2:-}" ]; then :; else
					shift
					_cmd="$1"
				fi
				;;
			-p | --bin | --path)
				if [ -z "${1:-}" ]; then :; else
					shift
					_bins="${_bins:+${_bins}"${sep}"}$1"
				fi
				;;
			--export-file | --rc)
				if [ -z "${1:-}" ]; then :; else
					shift
					cache_rc="$1"
					add_to_cache=true
				fi
				;;
			--no-export | --no-rc)
				add_to_cache=false
				;;
			-f | --force | --raw) action="override" ;;
			*)
				_args="${_args:+${_args}"${sep}"}$1"
				;;
			esac
			shift
		done

		#@ Parse positional arguments
		#TODO: This is not quite working
		#TODO: If the only argument provided, if it;s obviously a path (maybe with /), then assume it's a binary
		#TODO: use the basename of the binary to check if it's in path
		if [ -z "${_args:-}" ] && [ -n "${_var:-}${_cmd:-}${_bins:-}" ]; then :; else
			dots__pout --debug "Parsing positional arguments"
			#@ Split the arguments by the delimiter
			ifs="${IFS}"
			IFS="${sep}"

			#@ Count the number of arguments
			i=0
			for _ in ${_args}; do i=$((i + 1)); done
			_arg_count="${i}"

			#@ Iterate over the arguments
			i=0
			for _arg in ${_args}; do
				#@ Skip if the current argument is empty
				if [ -z "${_arg:-}" ]; then
					#@ Decrement the argument counter
					_arg_count=$((_arg_count - 1))
					continue
				else
					#@ Increment the counter
					i=$((i + 1))
					dots__pout --debug "$(
						printf "Argument %s or %s: %s\n" "${i}" "${_arg_count}" "${_arg}"
					)"
				fi

				#@ Define the role of the current argument
				if [ -z "${_var:-"${_cmd:-}"}" ]; then
					#@ Assume the current argument is a command
					_cmd="$(
						printf "%s" "${_arg:-}" |
							sed -e "s/\"//g" -e "s/\'//g" |
							tr '[:space:]' '_' | tr '-' '_' | tr -s '_' || true
					)"

					#@ Set the variable name to CMD_<COMMAND NAME>
					var_via_cmd="$(
						printf "CMD_%s" "${_cmd:-}" |
							tr '[:lower:]' '[:upper:]' || true
					)"

					#@ Skip the rest of the loop
					continue
				else
					#@ Collect the remaining arguments as possible script paths
					_bin="${_bin:+${_bin}"${sep}"}${_arg}"
				fi
			done

			#@ Restore the original IFS
			IFS="${ifs}"
		fi

		case "${action:-}" in update | force) ;; *)
			#@ Load the cache file, if it exists
			if [ -s "${cache_rc}" ]; then . "${cache_rc}"; fi
			;;
		esac

		#@ Check for a provided variable name
		if [ -n "${_var:-}" ]; then
			dots__pout --debug "Variable name provided: ${_var}"
		fi

		#@ Check if any of the provided binary paths are executable
		if [ -n "${_bins:-}" ]; then
			#@ Iterate over the binary paths for the first executable one
			for _bin in ${_bins}; do
				if [ -x "${_bin}" ]; then
					var_via_bin="$(
						#@ Set the variable name to CMD_<BIN_PATH_NAME>
						printf "CMD_%s" "$(basename "${_bin}")" |
							sed -e "s/\"//g" -e "s/\'//g" |
							tr '[:space:]' '_' |
							tr '-' '_' |
							tr -s '_' |
							tr '[:lower:]' '[:upper:]' ||
							true
					)"
					val_via_bin="${_bin}"
					break
				else
					echo No
				fi
			done
		fi

		if [ -n "${_cmd:-}" ]; then
			#@ Set the variable name to CMD_<COMMAND NAME>
			var_via_cmd="$(
				printf "CMD_%s" "${_cmd:-}" |
					sed -e "s/\"//g" -e "s/\'//g" |
					tr '[:space:]' '_' |
					tr '-' '_' |
					tr -s '_' |
					tr '[:lower:]' '[:upper:]' ||
					true
			)"
			#@ Retrieve the command information
			val_via_cmd="$(\type "${_cmd:-}" 2>/dev/null || true)"
			inf_via_cmd="$(printf '%s' "${val_via_cmd}" | head -n1 || true)"
			case "${inf_via_cmd:-"${val_via_cmd:-}"}" in
			*builtin | *keyword)
				dots__pout --debug "$(printf "'%s'" "${inf_via_cmd}")"
				;;
			"${_cmd}"*"() ")
				dots__pout --debug "$(
					printf "'%s' refers to the following functions\n%s" \
						"${_cmd}" "${val_via_cmd}"
				)"
				;;
			*aliased*)
				dots__pout --debug "$(
					printf "'%s' is an alias of the command below" \
						"${_cmd}" "${val_via_cmd}"
				)"
				;;
			*/* | *\\*)
				#@ Remove the leading "<command> is " prefix to isolate the path
				val_via_cmd="${val_via_cmd#"${_cmd}" is }"
				if [ -f "${val_via_cmd:-}" ]; then
					if [ -x "${val_via_cmd:-}" ]; then
						dots__pout --debug "$(
							printf "'%s' is a system-wide executable\n" "${_cmd}"
						)"
					else
						dots__pout --debug "$(
							printf \
								"'%s' is a file with inexecutable permissions\n" "${_cmd}"
						)"
						code=1
						return
					fi
				else
					dots__pout --debug "$(
						printf "'%s' is not a file\n%s" "${_cmd}" "${val_via_cmd}"
					)"
					code=1
					return
				fi
				;;
			*)
				#TODO: Handle other cases, this is a catch-all but not yet fail-safe
				if [ -n "${val_via_cmd:-}" ]; then :; else
					dots__pout --debug "Missing command: ${_cmd}"

					#@ Try bin_val
					if [ -n "${val_via_bin:-}" ]; then :; else
						dots__pout --debug "No viable command or binary found related to '${_cmd}'"
						code=1
						return
					fi
				fi
				;;
			esac
		fi

		#@ Normalize and set the command variable name
		cmd_var="${_var:-"${var_via_bin:-"${var_via_cmd:-}"}"}"

		#@ Check if the provided var is already set
		if [ -n "${cmd_var:-}" ]; then
			val_via_var="$(eval "printf '%s' \"\$${cmd_var:-}"\")"
			if [ -n "${val_via_var:-}" ]; then
				dots__pout --debug "${cmd_var}" is already set to "${val_via_var}" \\n
			else
				#@ Check if a command or binary path was provided?
				if [ -n "${var_via_cmd:-"${var_via_bin:-}"}" ]; then :; else
					dots__pout --debug "$(
						printf "'%s' %s %s\n" "${cmd_var}" \
							"was not found in the environment" \
							"and neither a command or binary path was provided to add it."
					)"
					code=1
					return
				fi
			fi
		else
			dots__pout --debug "$(printf "Variable name not defined\n")"
			code=1
			return
		fi

		val_old="${val_via_var:-}"
		val_new="${val_via_cmd:-"${val_via_bin:-}"}"

		#@ Handle the case where the variable is already set but is different
		case "${val_old:-""}" in
		"")
			cmd_val="${val_new:-}"
			change_triggered=true
			;;
		"${val_new:-}")
			cmd_val="${val_new:-}"
			;;
		*)
			case "${action:-}" in "override") ;; *)
				printf "The existing environment variable and the new one are different\n"
				printf "Old: %s\nNew: %s\nShould we proceed? [Y|n] => " \
					"${val_old}" "${val_new}"
				trap 'printf "CTRL + C\nOperation cancelled without any changes\n"; exit 137' INT
				read -r response
				case "${response:-Y}" in [yY]*)
					dots__pout --debug "The existing environment variable will be replaced\n"
					cmd_val="${val_new:-}"
					change_triggered=true
					;;
				*)
					dots__pout --debug "The existing environment variable will remain unchanged\n"
					cmd_val="${val_old:-}"
					;;
				esac
				;;
			esac
			;;
		esac

		#@ Set the command environment variable
		if [ -n "${cmd_var:-}" ] && [ -n "${cmd_val:-}" ]; then
			cmd_env="$(
				printf "%s=\"%s\" export %s" \
					"${cmd_var}" "${cmd_val}" "${cmd_var}"
			)"
		else
			dots__pout --debug "Requirements not met"
			code=1
			return
		fi

		#@ Write the command environment to the rc file if export is requested.
		case "${action:-}" in "override" | "export") change_triggered=true ;; *) ;; esac
		case "${add_to_cache:-}" in
		true | yes | on | 1)
			case "${change_triggered:-}" in true | yes | on | 1)
				#@ Write a full header to a file
				write_header() {
					_rc="$1"
					_action="${2:-Modified}"
					if {
						printf '%s\n' "#!/bin/sh"
						printf '%s\n' "# shellcheck enable=all"
						printf '# %s at: %s\n\n' "${_action}" "${timestamp}"
					} >"${_rc}"; then
						dots__pout --debug "Created the rc file with the header: " "${_rc}"
					else
						pout_error "Failed to write the header to the cache file"
						code=1
					fi
				}

				#@ Initialize variables
				rc_file="${cache_rc:-${DOTS}/cache/.dotsrc}"
				rc_file_tmp="${rc_file}.$}"
				rc_dir="$(dirname "${rc_file}")"

				#@ Set up cleanup trap for temporary files
				trap 'rm -f ${rc_file_tmp} 2>/dev/null || true' EXIT INT TERM

				#@ Add the command environment to the rc file
				case "${action:-}" in dry-run | simulate)
					dots__pout --debug "$(
						printf "Would add the following to '%s':\n%s\n" \
							"${rc_file}" "${cmd_env}"
					)"
					;;
				*)

					#@ Ensure the parent directory of the rc file exists
					if [ -d "${rc_dir}" ]; then
						if [ -w "${rc_dir}" ]; then
							dots__pout --debug "Proceeding with cache directory: " "${rc_dir}"
						else
							dots__pout --debug "Insufficient permissions for rc directory: " "${rc_dir}"
							code=1
							return
						fi
					else
						if mkdir -p "${rc_dir}"; then
							dots__pout --debug "Created directory: " "${rc_dir}"
						else
							dots__pout --debug "Failed to create directory: " "${rc_dir}"
							code=1
							return
						fi
					fi
					#@ Ensure the rc file exists and is writable
					if [ -e "${rc_file}" ]; then
						if [ -w "${rc_file}" ]; then
							dots__pout --debug "Proceeding with cache file: " "${rc_file}"
						else
							dots__pout --debug "Cache file exists but is not writable: " "${rc_file}"
							code=1
							return
						fi
					else
						#@ Try to create the rc file with the header
						write_header "${rc_file}" "Generated"
						if [ "${code}" -ne 0 ]; then return; fi
					fi

					if [ ! -f "${rc_file}" ] || [ ! -s "${rc_file}" ]; then
						write_header "${rc_file}" "Generated"
						if [ "${code}" -ne 0 ]; then return; fi
					elif ! grep -E '^# (Generated|Modified) at:' "${rc_file}" >/dev/null 2>&1; then
						write_header "${rc_file_tmp}" "Generated"
						if [ "${code}" -ne 0 ]; then return; fi

						#@ Append the contents of the rc file to the temp file
						cat "${rc_file}" >>"${rc_file_tmp}"

						#@ Replace the original rc file with the temp file
						mv "${rc_file_tmp}" "${rc_file}"
					else
						#@ Modify the timestamp line while preserving all other content
						sed "1,/^# \(Generated\|Modified\) at: .*/ s/^# \(Generated\|Modified\) at: .*/# Modified at: ${timestamp}/" "${rc_file}" >"${rc_file_tmp}"
						mv "${rc_file_tmp}" "${rc_file}"
					fi
					#@ Extract variable name and value from cmd_env
					var_name=$(printf "%s" "${cmd_env}" | cut -d'=' -f1)
					var_value=$(printf "%s" "${cmd_env}" | cut -d'=' -f2- | cut -d' ' -f1)

					#@ First check if the variable exists as an uncommented line
					if grep -Eq "^${var_name}=" "${rc_file:-}" || grep -Eq "^${var_name} " "${rc_file:-}"; then
						#@ Do nothing as the line already exists and is uncommented
						:
					elif grep -Eq "^#[ ]*${var_name}=${var_value}" "${rc_file:-}"; then
						#@ Uncomment the line if it has the same value (POSIX-compliant approach)
						sed "s|^#[ ]*\(${var_name}=${var_value}.*\)|\1|" "${rc_file:-}" >"${rc_file_tmp}"
						mv "${rc_file_tmp}" "${rc_file:-}"
					else
						#@ Check if there's a commented version with different value
						line_num=$(grep -n "^#[ ]*${var_name}=" "${rc_file:-}" | cut -d':' -f1 | head -1)

						if [ -n "${line_num}" ]; then
							#@ Add the new line right after the commented one (POSIX-compliant approach)
							{
								sed "${line_num}q" "${rc_file:-}"
								printf "%s\n" "${cmd_env}"
								sed "1,${line_num}d" "${rc_file:-}"
							} >"${rc_file_tmp}"
							mv "${rc_file_tmp}" "${rc_file:-}"
						else
							#@ If no version exists at all, append to the end
							printf "%s\n" "${cmd_env}" >>"${rc_file:-}"
						fi
					fi
					;;
				esac
				;;
			*) dots__pout --debug "No changes were necessary to add to the rc file" ;; esac
			;;
		*) dots__pout --debug "RC File updates are disabled" ;; esac

		#@ Load the command environment
		if [ -n "${cmd_env:-}" ] && [ "${code}" -eq 0 ]; then
			eval "${cmd_env}" #? This works only if sourced
		fi
	}
}

dots__set_editor() {
	CMD_EDITOR="${CMD_EDITOR:-"$(
		command -v editor 2>/dev/null ||
			"${DOTS}/Bin/shellscript/packages/defaults/editor" || true
	)"}"
	if [ -x "${CMD_EDITOR}" ]; then
		EDITOR_GUI="${editors_gui}"
		EDITOR_TUI="${editors_tui}"
		export EDITOR_GUI EDITOR_TUI

		EDITOR="$(editor --set)"
		export EDITOR
	fi
}

dots__cleanup() {
	unset ctx verbosity reset
}

dots__init_bin() {
	#@ Define configuration
	BIN_ROOT="${DOTS}/Bin"
	BIN_DEPTH=10
	BIN_IGNORE="review tmp temp archive"
	DOTS_PATH=""
	dir_count=0

	#@ Filter binary directories
	BIN_IGNORE_PATTERN=$(printf "%s" "$BIN_IGNORE" | tr ' ' '|')
	BIN_DIRS="$(
		find "${BIN_ROOT}" -maxdepth "${BIN_DEPTH}" -type d |
			grep -v -E "/(${BIN_IGNORE_PATTERN})$" || true
	)"

	#@ Add all matching directories to PATH
	for dir in ${BIN_DIRS:-}; do
		#@ Skip if directory doesn't exist.
		[ -d "${dir}" ] || continue

		#@ Ensure all files are executable
		# chmod +x -c "${dir}"
		# find "${dir}" -type f -print0 | xargs -0 chmod +x -c

		#@ Skip if already in PATH
		case ":${PATH}:" in *"${dir}"*) ;; *)
			DOTS_PATH="${DOTS_PATH:+"${DOTS_PATH}:"}${dir}"
			dir_count=$((dir_count + 1))
			;;
		esac
	done

	if [ -z "${DOTS_PATH:-}" ]; then :; else
		dots__pout --debug "%s\n" "${DOTS_PATH}" | tr ":" "\n"
		dots__pout --info "PATH updated with ${dir_count:-0} bin directories"
		PATH="${DOTS_PATH}:${PATH}"
	fi
}

dots__init_config() {
	init_git() {
		git config include.path "${GIT_CONFIG:-"${DOTS}/Configuration/git/main.gitconfig"}"
	}

	init_sh() {
		CMD_SH="$(command -v sh 2>/dev/null || true)"

		#@ Skip if the command or binary directory are missing
		if [ -x "${CMD_SH}" ]; then :; else return; fi
		if [ -d "${DOTS_BIN_SH:-"${DOTS}/Bin/shellscript"}" ]; then :; else return 1; fi

		#@ Set defaults and initialize counters
		depth_limit=4
		updated_count=0
		skipped_count=0
		new_path=""

		#@ Define cleanup function
		init_sh__cleanup() {
			unset updated_count skipped_count new_path depth_limit
		}

		#@ Set trap for proper cleanup
		trap init_sh__cleanup EXIT HUP INT TERM

		dots__pout --ctx "init_sh" --debug "Processing directories (depth: ${depth_limit})"

		#@ Process directories with limited recursion using pure shell
		process_dir() {
			dir="$1"
			current_depth="$2"

			#@ Check if we've reached depth limit
			[ "${current_depth}" -gt "${depth_limit}" ] && return

			#@ Check if directory is in excluded patterns
			case "${dir}" in
			*archive* | *review* | *temp* | *tmp*) return ;;
			*) ;;
			esac

			#@ Add directory to PATH if needed
			case ":${PATH}:" in
			*":${dir}:"*)
				skipped_count=$((skipped_count + 1))
				;;
			*)
				new_path="${new_path:+${new_path}:}${dir}"
				updated_count=$((updated_count + 1))
				;;
			esac

			#@ Only process subdirectories if we're not at max depth
			[ "${current_depth}" -eq "${depth_limit}" ] && return

			#@ Process subdirectories
			for subdir in "${dir}"/*; do
				[ -d "${subdir}" ] && process_dir "${subdir}" "$((current_depth + 1))"
			done
		}

		#@ Start recursive processing at depth 1
		process_dir "${DOTS_BIN_SH}" 3

		#@ Update PATH if we found new directories
		if [ -n "${new_path}" ]; then
			PATH="${new_path}:${PATH}"
			export PATH
		fi

		#@ Report the results
		dots__pout --ctx "init_sh" --info \
			"Processed binary directories - " \
			"Added: ${updated_count}" " | " \
			"Skipped: ${skipped_count}"

		#@ Cleanup
		init_sh__cleanup

		return 0
	}

	init_sh_OLD() {
		#@ Skip if the command or binary directory are missing
		if [ -x "${CMD_SH}" ]; then :; else return; fi
		if [ -d "${DOTS_BIN_SH}" ]; then :; else return; fi

		#@ Set defaults
		search_depth=5
		exclude_patterns="archive review temp tmp"
		exclude_patterns="$(printf "%s" "${exclude_patterns}" | sed 's/ /|/g')"
		bin_dirs="" bin_dir_count=0
		include="" include_count=0
		exclude="" exclude_count=0
		skipped="" skipped_count=0
		updated="" updated_count=0

		#@ Identify valid binary subdirectories.
		#TODO: we shouldn't have to perform find thrice
		bin_dirs="$(
			find "${DOTS_BIN_SH}" -maxdepth "${search_depth}" -type d |
				tr '\n' "${DELIMITER}"
		)"
		include="$(
			find "${DOTS_BIN_SH}" -maxdepth "${search_depth}" -type d |
				grep -Ev "${exclude_patterns}" | tr '\n' "${DELIMITER}"
		)"
		exclude="$(
			find "${DOTS_BIN_SH}" -maxdepth "${search_depth}" -type d |
				grep -E "${exclude_patterns}" | tr '\n' "${DELIMITER}"
		)"

		#@ Update the print delimiter
		old_ifs="${IFS}"
		IFS="${DELIMITER}"

		#@ Store the total number of directories in each category
		bin_dir_count="$(printf "%s" "${bin_dirs}" | tr "${DELIMITER}" "\n" | wc -l)"
		include_count="$(printf "%s" "${include}" | tr "${DELIMITER}" "\n" | wc -l)"
		exclude_count="$(printf "%s" "${exclude}" | tr "${DELIMITER}" "\n" | wc -l)"

		dots__pout --ctx "init_sh" --trace "bin_dir_count:" "${bin_dir_count}"
		dots__pout --ctx "init_sh" --trace "include_count:" "${include_count}"
		dots__pout --ctx "init_sh" --trace "exclude_count:" "${exclude_count}"

		# PATH="${PATH}:/c/Users/Administrator/.dots/Bin/shellscript/cmd"

		#@ Identify the directories to be added to the PATH
		i=0
		for bin_dir in ${include}; do
			i=$((i + 1))
			dots__pout --ctx "init_sh" --trace "${i}: ${bin_dir}"
			case "${PATH}" in
			"${bin_dir}"* | *":${bin_dir}:"* | ":${bin_dir}")
				skipped_count=$((skipped_count + 1))
				skipped="${skipped:+${skipped}${DELIMITER}}${bin_dir}"
				dots__pout --ctx "init_sh" --trace "Found in PATH:" "${i}>" "${bin_dir}"
				;;
			*)
				updated_count=$((updated_count + 1))
				updated="${updated:+${updated}${DELIMITER}}${bin_dir}"
				dots__pout --ctx "init_sh" --trace "Added to PATH:" "${i}>" "${bin_dir}"
				new_path="${new_path:+${new_path}":"}${bin_dir}"
				;;
			esac
		done

		printf "PATH:\n%s" "${new_path:-}"

		#@ Update the PATH variable, if necessary
		PATH="${new_path}:${PATH}" export PATH

		#@ Report the results
		dots__pout --ctx "init_sh" --info \
			"Processed" "${bin_dir_count}" "binary directories\n" \
			"Valid: ${include_count}" " | " \
			"Invalid: ${exclude_count}" " | " \
			"Skipped: ${skipped_count}" " | " \
			"Added: ${updated_count}"

		#@ Cleanup
		IFS="${old_ifs}"
		unset p b
	}

	init_bash() {
		#@ Skip if the command or binary directory are missing
		if [ -x "${CMD_BASH:-}" ]; then :; else return; fi
		if [ -d "${DOTS_BIN_BASH:-}" ]; then :; else return; fi

		#@ Check if the binary directory exists
		p="${PATH}"
		b="${DOTS_BIN_BASH}"
		#@ Update the PATH variable, if necessary
		case "${p}" in
		"${b}:"* | *":${b}:"* | ":${b}")
			dots__pout --debug "PATH includes: ${DOTS_BIN_BASH}"
			;;
		*)
			PATH="${DOTS_BIN_BASH}:${PATH}" export PATH
			dots__pout --debug "PATH updated to include: ${DOTS_BIN_BASH}"
			;;
		esac

		#@ Cleanup
		unset p b
	}

	init_nushell() {
		if [ -z "${CMD_NU}" ]; then return; else

			#@ Check if the nushell binary directory exists
			if [ -d "${DOTS_BIN_NU}" ]; then
				case "${PATH}" in
				"${DOTS_BIN_NU}:"* | *":${DOTS_BIN_NU}:"* | ":${DOTS_BIN_NU}") ;;
				*)
					unset "${DOTS_BIN_NU}"
					return
					;;
				esac
			fi
		fi

		#@ Prepend the nushell binary directory to the PATH
		if [ -z "${DOTS_BIN_NU}" ]; then :; else
			PATH="${DOTS_BIN_NU}:${PATH}" export PATH
			dots__pout --debug "Added to PATH: ${DOTS_BIN_SH}"
		fi
	}

	init_blesh() {
		CMD_BLESH="${HOME:-}/.local/share/blesh/ble.sh"
		if [ -f "${CMD_BLESH}" ]; then
			"${CMD_BLESH}" >/dev/null 2>&1
			dots__pout --debug "[INFO] /> dotsrc <\ Initialized Ble.sh"
		else
			dots__pout --debug "[ERROR] /> dotsrc <\ Missing Dependency: " "${CMD_BLESH}"
		fi
	}

	init_atuin() {
		CMD_ATUIN="$(command -v atuin 2>/dev/null || printf "")"
		if [ -x "${CMD_ATUIN}" ]; then
			eval "$(atuin init bash --disable-ctrl-r || true)"
			dots__pout --debug "[INFO] /> dotsrc <\ Initialized Atuin"
		else
			dots__pout --debug "[ERROR] /> dotsrc <\ Missing Dependency: " "${CMD_ATUIN}"
		fi
	}

	init_starship() {
		#@ Retrieve the path to the starship binary
		CMD_STARSHIP="$(command -v starship 2>/dev/null || true)"

		if [ -x "${CMD_STARSHIP:-}" ]; then
			export CMD_STARSHIP

			#@ Skip if starship already initiated
			if [ -z "${STARSHIP_START_TIME:-}" ]; then :; else
				dots__pout --debug "[INFO] /> dotsrc <\ Starship already initiated"
				return 0
			fi

			#@ Use the custom configuration file if it exists
			starship_config="${DOTS}/Configuration/starship/config.toml"
			if [ ! -f "${starship_config}" ]; then :; else
				STARSHIP_CONFIG="${starship_config}"
				export STARSHIP_CONFIG
			fi

			#@ Initialize starship
			eval "$(starship init bash || true)"
			dots__pout --debug "[INFO] /> dotsrc <\ Initialized Starship"
		else
			dots__pout --debug "[ERROR] /> dotsrc <\ Missing Dependency: starship"
		fi
	}

	init_oh_my_posh() {
		CMD_OMP="$(
			command -v omp 2>/dev/null ||
				printf "%s" "${DOTS}/Bin/shellscript/packages/alias/omp"
		)"

		if [ -x "${CMD_OMP:-}" ]; then
			eval "$(omp --set "${1:-}" || true)"
		fi
	}

	init_fastfetch() {
		#@ Retrieve the path to the fastfetch binary
		CMD_FASTFETCH="$(command -v starship 2>/dev/null || true)"

		if [ -x "${CMD_FASTFETCH}" ]; then
			export CMD_FASTFETCH

			#@ Check if the starship configuration file exists
			fastfetch_config="${DOTS}/Configuration/fastfetch/config.jsonc"

			#@ Initialize fastfetch
			if [ -f "${fastfetch_config}" ]; then
				FASTFETCH_CONFIG="${fastfetch_config}"
				export FASTFETCH_CONFIG
				fetch() { fastfetch --config "${FASTFETCH_CONFIG}"; }
			else
				fetch() { fastfetch; }
			fi
			fetch

			dots__pout --debug "[INFO] /> dotsrc <\ Initialized Fastfetch"
		else
			dots__pout --debug "[ERROR] /> dotsrc <\ Missing Dependency: " "${CMD_FASTFETCH}"
		fi
	}

	init_projects() {
		rc=".dotsrc"
		[ -f "${PRJ_CC}/${rc}" ] && . "${PRJ_CC}/${rc}"
		[ -f "${PRJ_CRAOLE}/${rc}" ] && . "${PRJ_CRAOLE}/${rc}"
		[ -f "${PRJ_CRAOLE}/${rc}" ] && . "${PRJ_CRAOLE}/${rc}"
		unset rc
	}
}

dots__init_scripts() {

	fetch_info() {
		fetch_info__os() {
			CMD_NIXOS_VERSION="$(command -v nixos-version 2>/dev/null)"
			CMD_POWERSHELL="$(command -v powershell 2>/dev/null)"
			CMD_PWSH="$(command -v pwsh 2>/dev/null)"
			CMD_POWERSHELL="${CMD_PWSH:-"${CMD_POWERSHELL:-}"}"
			CMD_CMD="$(command -v cmd.exe 2>/dev/null)"

			#@ Retrieve bulk system info (lowercase)
			system_info() {
				if uname -a >/dev/null 2>&1; then
					uname -a
				elif [ -f /proc/version ]; then
					cat /proc/version 2>/dev/null || true
				else
					printf ""
				fi | tr '[:upper:]' '[:lower:]' || true
			}

			is_wsl() {
				system_info | grep -q "microsoft"
			}

			nixos_version() {
				if [ -x "${CMD_NIXOS_VERSION:-}" ]; then
					#@ Print the OS name
					printf "%s" "NixOS"

					#@ Extract the major and minor part of the version
					_ver="$(nixos-version | cut -d. -f1,2)"

					#@ Append the version
					printf "_%s" "${_ver}"
				else
					return 1
				fi
			}

			windows_version() {
				#@ Print the OS name
				printf "%s" "Windows"

				#@ Append the version
				if [ -x "${CMD_POWERSHELL:-}" ]; then
					_ver="$(
						"${CMD_POWERSHELL}" -NoProfile -Command "[System.Environment]::OSVersion.Version.ToString()" \
							2>/dev/null | tr -d '\r\n'
					)"
					if [ -z "${_ver}" ]; then :; else printf "_%s" "${_ver}"; fi
				elif [ -x "${CMD_CMD}" ]; then
					"${CMD_CMD}" /c ver | grep -oE '[0-9]+\.[0-9]+\.[0-9]+' | head -n1
				else
					printf "11"
				fi
			}

			macos_version() {
				printf "MacOS_"
				sw_vers -productVersion 2>/dev/null | cut -d. -f1,2
			}

			os_type() {
				uname -s 2>/dev/null | tr '[:upper:]' '[:lower:]' || printf ""
			}

			os_ver() {
				if uname -r >/dev/null 2>&1; then
					printf "_%s" "$(uname -r)"
				else
					printf ""
				fi
			}

			#@ Detect OS
			case "$(system_info)" in
			*nixos*) nixos_version ;;
			*linux*) printf "%s%s" "Linux" "$(os_ver)" ;;
			*msys* | *ming* | *cygwin*) windows_version ;;
			*darwin*) macos_version ;;
			*) printf "%s%s" "$(os_type)" "$(os_ver)" ;;
			esac

			#@ Detect WSL
			case "$(system_info)" in *wsl*) printf "_WSL" ;; *) ;; esac
		}

		fetch_info__user() {
			printf "%s" "${USER:-"${USERNAME:-""}"}"
		}

		fetch_info__host() {
			uname -n || hostname || printf ""
		}

		fetch_info__all() {
			printf "%s@%s on %s%s" \
				"$(fetch_info__user)" \
				"$(fetch_info__host)" \
				"$(fetch_info__os)" \
				""
		}

		if [ "$#" -lt 1 ]; then
			fetch_info__all
		else
			while [ "$#" -ge 1 ]; do
				case "$1" in
				--os) fetch_info__os ;;
				--user) fetch_info__user ;;
				*) fetch_info__all ;;
				esac
				shift
			done
		fi
	}

	pout() {
		pout__main() {
			pout__set_local_env
			pout__parse_arguments "$@"
			pout__execute
		}

		pout__set_local_env() {
			ctx_sep="${ctx_sep:-"-|-"}"
			pout_tag=""
			pout_ctx=""
			pout_msg=""
			pout_ctx_tag=""
			path_limit=""
			path_limit_start="head"
			path=""
			delimiter="${DELIMITER:-"$(printf "\037")"}"
			old_ifs="${IFS}"
			IFS="${delimiter}"
		}

		pout__parse_arguments() {
			while [ "$#" -ge 1 ]; do
				case "$1" in
				--ctx)
					pout_ctx="$2"
					shift
					;;
				--trace) pout_tag="TRACE" ;;
				--test) pout_tag="TEST" ;;
				--debug) pout_tag="DEBUG" ;;
				--info) pout_tag="INFO" ;;
				--warn) pout_tag="WARN" ;;
				--err* | --fatal | --fail*]) pout_tag="ERROR" ;;
				--path)
					pout_tag="PATH"
					while [ "$#" -ge 2 ]; do
						case "$2" in
						--tail | --head)
							path_limit_start="${2#--}"
							path_limit="${path_limit:-1}"
							;;
						*)
							path_limit="${2:-"all"}"
							;;
						esac
						shift
					done
					break
					;;
				--) break ;;
				--*)
					if [ "$#" -eq 1 ]; then :; else
						shift
						for arg in "$@"; do
							pout_msg="${pout_msg:+"${pout_msg}${delimiter}"}${arg:-}"
						done
					fi
					break
					;;
				*)
					pout_msg="${pout_msg:+"${pout_msg}${delimiter}"}${1}"
					;;
				esac
				shift
			done

			#@ Build tag with flag and context
			pout_ctx="${pout_ctx:-"${ctx}"}"
			if [ -z "${pout_tag:-}" ]; then :; else
				case "$(to_lower "${pout_tag:-}")" in
				path) pout_ctx_tag="${pout_ctx}${ctx_sep}${pout_tag}" ;;
				*) pout_ctx_tag="${pout_tag}${ctx_sep}${pout_ctx}" ;;
				esac
			fi

			if [ -z "${pout_ctx_tag}" ]; then :; else
				pout_ctx_tag_head="${ctx_head:-"/> "}"
				pout_ctx_tag_tail="${ctx_tail:-" <\ "}"
				pout_ctx_tag="${pout_ctx_tag_head}${pout_ctx_tag}${pout_ctx_tag_tail}"
			fi

			#@ Replace the delimiter with a space
			pout_msg="$(
				printf "%b" "${pout_msg}" | tr "${delimiter}" " " || true
			)"
		}

		pout__execute() {
			#@ Print the message
			case "$(to_lower "${pout_tag:-}")" in
			test*)
				if [ "${verbosity:-0}" -lt "${VERBOSITY_TRACE:-5}" ]; then :; else
					printf "\n%b%b\n" "${pout_ctx_tag}" "${pout_msg}"
					eval "${pout_msg}"
				fi
				;;
			trace*)
				if [ "${verbosity:-0}" -lt "${VERBOSITY_TRACE:-5}" ]; then :; else
					printf "%b%b\n" "${pout_ctx_tag}" "${pout_msg}"
				fi
				;;
			debug*)
				if [ "${verbosity:-0}" -lt "${VERBOSITY_DEBUG:-4}" ]; then :; else
					printf "%b%b\n" "${pout_ctx_tag}" "${pout_msg}"
				fi
				;;
			info*)
				if [ "${verbosity:-0}" -lt "${VERBOSITY_INFO:-3}" ]; then :; else
					printf "%b%b\n" "${pout_ctx_tag}" "${pout_msg}"
				fi
				;;
			warn*)
				if [ "${verbosity:-0}" -lt "${VERBOSITY_WARN:-2}" ]; then :; else
					printf "%b%b\n" "${pout_ctx_tag}" "${pout_msg}"
				fi
				;;
			error*)
				if [ "${verbosity:-0}" -lt "${VERBOSITY_ERROR:-1}" ]; then :; else
					printf "%b%b\n" "${pout_ctx_tag}" "${pout_msg}"
				fi
				;;
			path*)
				#@ Print the tag
				printf "%b\n" "${pout_ctx_tag}"

				#@ Retrieve the paths from the PATH
				path="$(printf "%s" "${PATH}" | tr ':' '\n')"
				path_count="$(printf "%s" "${PATH}" | tr ':' '\n' | wc -l)"
				[ "${path_count:-0}" -gt 0 ] || {
					dots__pout --debug "[ERROR] /> ${ctx} <\ PATH is empty"
					return 1
				}

				#@ Limit the results, if necessary
				if [ "${path_limit:-}" -eq "${path_limit:-}" ] >/dev/null 2>&1; then
					#@ Calculate starting index based on limit
					case "${path_limit_start}" in
					tail)
						start_idx=$((path_count - path_limit + 1))
						[ "${start_idx}" -lt 1 ] && start_idx=1
						path="$(printf "%s" "${path}" | tail -n "${path_limit}")"
						;;
					*)
						start_idx=1
						path="$(printf "%s" "${path}" | head -n "${path_limit}")"
						;;
					esac
				else
					start_idx=1
				fi

				#@ Print the path
				i=$((start_idx - 1))
				for p in ${path}; do
					i=$((i + 1))
					printf "%3d %s %s\n" "${i}" "${ctx_sep}" "${p}"
				done

				#@ Cleanup
				unset path i p start_idx path_count path_limit path_limit_start
				;;
			print | *) printf "%b" "${pout_msg}" ;;
			esac

			#@ Cleanup
			IFS="${old_ifs}"
		}

		pout__main "$@"
	}

	watchsh() {
		watchsh__cleanup() {
			#@ Remove variables from the environment
			unset _secs _args watch_cmd secs delimiter args args_file os_type

			#@ Remove the temporary file
			[ -n "${args_file}" ] && [ -f "${args_file}" ] &&
				rm -f "${args_file}" 2>/dev/null
		} && watchsh__cleanup

		#@ Set initial exit trap
		trap watchsh__cleanup EXIT HUP INT TERM

		#@ Initialize variables
		secs=10
		args="${DOTS_RC}"
		opts="--resetTerminal"
		status=0
		delimiter="${DELIMITER:-"$(printf "\037")"}"

		#@ Determine OS type
		os_type="${OS_TYPE:-"$(fetch_info --os)"}"
		os_type="$(to_lower "${os_type}")"

		#@ Create a secure temporary file for argument storage (cross-platform)
		args_file=""
		for _tmp_dir in "${TMPDIR:-/tmp}" /var/tmp /tmp; do
			{ [ -d "${_tmp_dir}" ] && [ -w "${_tmp_dir}" ]; } || continue

			#@ Create unique filename using PID and timestamp (POSIX-compliant)
			args_file="${_tmp_dir}/watchsh_args.$$.$(/bin/date +%s 2>/dev/null || printf "%s" $$)"
			touch "${args_file}" 2>/dev/null || continue

			#@ Restrict permissions if the OS allows
			case "${os_type}" in
			*linux* | *darwin* | *bsd*) chmod 600 "${args_file}" 2>/dev/null || true ;;
			*) ;;
			esac

			[ -f "${args_file}" ] && [ -w "${args_file}" ] && break
		done

		#@ Check if the temporary file was created successfully
		if [ ! -f "${args_file:-}" ] || [ ! -w "${args_file:-}" ]; then
			dots__pout --ctx "watchsh" --error "Failed to create the temporary file"

			#@ Terminate the script with a non-zero status
			watchsh__cleanup
			return 1
		fi

		#@ Check if the watch command exists
		if [ -z "${CMD_WATCH}" ]; then
			dots__pout --ctx "watchsh" --error \
				"Missing dependency: watch" \
				"\nCheck it out at https://github.com/echocat/watch/\n"

			#@ Terminate the script with a non-zero status
			watchsh__cleanup
			return 1
		fi

		#@ Parse arguments
		_args=""
		while [ "$#" -gt 0 ]; do
			#@ Check if argument is a number (for seconds)
			if [ -z "${_secs}" ] && [ "$1" -eq "$1" ] 2>/dev/null; then
				_secs="$1"
			else
				#@ Handle arguments differently based on OS
				if [ "${os_type}" = "windows" ]; then
					#@ Windows/MSYS needs different escaping
					_escaped_arg="$(printf "%s" "$1" | sed 's/"/\\"/g')"
					_args="${_args:+${_args}${delimiter}}\"${_escaped_arg}\""
				else
					#@ Unix-style escaping
					_escaped_arg="$(printf "%s" "$1" | sed "s/'/'\\\\''/g")"
					_args="${_args:+${_args}${delimiter}}'${_escaped_arg}'"
				fi
			fi
			shift
		done

		#@ Store args in the temporary file if we have any
		if [ -n "${_args}" ]; then
			printf "%s" "${_args}" >"${args_file}"
		fi

		#@ Use provided args or default
		if [ -s "${args_file}" ]; then
			#@ Read arguments from file if it exists and is not empty
			args="$(tr "${delimiter}" " " <"${args_file}")"
		else
			dots__pout --ctx "watchsh" --debug \
				"No arguments provided, using default:" "${args}"
		fi

		#@ Update the options to include the refresh interval
		secs="${_secs:-${secs}}"
		opts="${opts} --interval ${secs}s"

		#@ Build and execute the command
		watch_cmd="${CMD_WATCH} ${opts} sh -c ${args}"
		dots__pout --ctx "watchsh" --debug "Executing:" "${watch_cmd}"
		eval "${watch_cmd}"
		status=$?
		#@ Handle exit status with more descriptive messages
		case "${status}" in
		0) dots__pout --ctx "watchsh" --debug "Completed successfully" ;;
		130) dots__pout --ctx "watchsh" --debug "Terminated by user (Ctrl+C)" ;;
		143) dots__pout --ctx "watchsh" --warn "Terminated by external signal" ;;
		*) dots__pout --ctx "watchsh" --error "Exited with status: ${status}" ;;
		esac

		#@ Terminate the script with execution status
		watchsh__cleanup
		return "${status}"
	}

	manage_tempfile() {
		#@ Handle temp file operations with proper cleanup
		temp_action=""
		temp_file=""

		#@ Parse arguments
		while [ $# -gt 0 ]; do
			case "$1" in
			--write)
				temp_action="write"
				shift
				;;
			--read)
				temp_action="read"
				temp_file="$2"
				shift 2
				;;
			--cleanup)
				temp_action="cleanup"
				temp_file="$2"
				shift 2
				;;
			*) shift ;;
			esac
		done

		#@ Handle actions based on the provided flag
		case "${temp_action}" in
		write)
			#@ Try various temp directories
			for _tmp_dir in "${TMPDIR:-/tmp}" /var/tmp /tmp; do
				{ [ -d "${_tmp_dir}" ] && [ -w "${_tmp_dir}" ]; } || continue
				temp_file="${_tmp_dir}/${ctx}_temp.$$.$(/bin/date +%s 2>/dev/null || printf "%s" $$)"
				touch "${temp_file}" 2>/dev/null || continue

				#@ Restrict permissions if possible
				case "${OS_TYPE:-}" in
				*linux* | *darwin* | *bsd*) chmod 600 "${temp_file}" 2>/dev/null || true ;;
				*) ;;
				esac

				[ -f "${temp_file}" ] && [ -w "${temp_file}" ] && break
			done

			#@ Return the temp file path
			printf "%s" "${temp_file}"
			return 0
			;;

		read)
			[ -f "${temp_file}" ] && cat "${temp_file}"
			return $?
			;;

		cleanup)
			[ -f "${temp_file}" ] && rm -f "${temp_file}" 2>/dev/null
			return $?
			;;

		*)
			return 1
			;;
		esac
	}

	pathman() {
		pathman__cleanup() {
			unset updated_count skipped_count new_path depth_limit
		} && pathman__cleanup
		#@ Set initial exit trap

		pathman__main() {
			trap pathman__cleanup EXIT HUP INT TERM
			pathman__set_local_env
			pathman__parse_args "$@"
		}

		pathman__set_local_env() {
			pathman_action="print"
			pathman_cmd=""
			pathman_args=""
		}

		pathman__parse_args() {
			while [ "$#" -gt 0 ]; do
				case "$1" in
				add)
					shift
					pathman__add "$@"
					status="$?"
					return "${status}"
					;;
				*) shift ;;
				esac
			done
		}
		pathman__add() {
			#@ Set defaults and initialize counters
			starting_dir="$1"
			depth_limit="${2:-4}"
			updated_count=0
			skipped_count=0
			new_path=""

			#@ Skip if the command or binary directory are missing
			if [ -x "${CMD_SH:-}" ]; then :; else return; fi
			if [ -d "${starting_dir:-}" ]; then :; else return; fi

			#@ Define cleanup function
			init_sh__cleanup() {
				unset updated_count skipped_count new_path depth_limit
			}

			#@ Set trap for proper cleanup
			trap init_sh__cleanup EXIT HUP INT TERM

			dots__pout --ctx "init_sh" --debug "Processing directories (depth: ${depth_limit})"

			#@ Process directories with limited recursion using pure shell
			process_dir() {
				dir="$1"
				current_depth="$2"
				#TODO: Depth is not working as depth but actually as limit so if it set the num to 10 it manages 9 dirs, if i set it to 100 it manages 99

				#@ Check if we've reached depth limit
				[ "${current_depth}" -gt "${depth_limit}" ] && return

				#@ Check if directory is in excluded patterns
				#TODO: Allow definition via parser
				case "${dir}" in
				*archive* | *review* | *temp* | *tmp*) return ;;
				*) ;;
				esac

				#@ Add directory to PATH if needed
				case ":${PATH}:" in
				*":${dir}:"*)
					skipped_count=$((skipped_count + 1))
					;;
				*)
					new_path="${new_path:+${new_path}:}${dir}"
					updated_count=$((updated_count + 1))
					;;
				esac

				#@ Only process subdirectories if we're not at max depth
				[ "${current_depth}" -eq "${depth_limit}" ] && return

				#@ Process subdirectories
				for subdir in "${dir}"/*; do
					[ -d "${subdir}" ] && process_dir "${subdir}" "$((current_depth + 1))"
				done
			}

			#@ Start recursive processing at depth 1
			process_dir "${starting_dir}" 1

			#@ Update PATH if we found new directories
			if [ -n "${new_path}" ]; then
				PATH="${new_path}:${PATH}"
				export PATH
			fi

			#@ Report the results
			dots__pout --ctx "init_sh" --info \
				"Processed binary directories - " \
				"Added: ${updated_count}" " | " \
				"Skipped: ${skipped_count}"

			#@ Cleanup
			init_sh__cleanup

			return 0
		}

		pathman__main "$@"
		return $?
	}

	to_upper() {
		printf "%s" "$*" | tr '[:lower:]' '[:upper:]'
	}

	to_lower() {
		printf "%s" "$*" | tr '[:upper:]' '[:lower:]'
	}

	quote() {
		os_type="${OS_TYPE:-"$(fetch_info --os)"}"

		while [ "$#" -gt 0 ]; do
			case "$1" in
			--single) quote__single "$2" ;;
			--escape) ;;
			--none) quote__remove "$2" ;;
			--double | *) ;;
			esac
			shift
		done

		quote__remove() {
			printf "%s" "$*" | tr -d "\"" | tr -d "\'"
		}

		quote__double() {
			esc="$(printf "%s" "$1" | sed 's/"/\\"/g')"
		}

		quote__single() {
			case "${os_type:-}" in
			windows)
				esc="$(printf "%s" "$1" | sed 's/"/\\"/g')"
				printf "\"%s\"" "${esc}"
				;;
			*)
				esc="$(printf "%s" "$1" | sed "s/'/'\\\\''/g")"
				printf "\'%s\'" "${esc}"
				;;
			esac
		}

		quote__escape() {
			:
		}
	}

	to_unquoted() {
		printf "%s" "$*" | tr -d "\"" | tr -d "\'"
	}

	swap_DELIMITER() {
		#@ Set defaults
		_sep="${DELIMITER:-"${DELIMITER:- }"}"
		_old="${_sep}" _new=" "
		_str="" _res=""

		#@ Parse arguments
		while [ "$#" -gt 0 ]; do
			case "$1" in
			--old*)
				_old="$2"
				shift
				;;
			--new*)
				_new="$2"
				shift
				;;
			--str*)
				_str="${_str:+${_str}${_sep}}$2"
				shift
				;;
			*) _str="${_str:+${_str}${_sep}}$1" ;;
			esac
			shift
		done

		#@ Build the string with the old DELIMITER
		old_ifs="${IFS}"
		IFS="${_sep}"
		for val in ${_str:-}; do
			_res="${_res:+${_res}${_old}}${val}"
		done
		IFS="${old_ifs}"

		#@ Output
		printf "%s" "${_res}" | tr "${_old}" "${_new}"
	}

	dev() {
		case "$(fetch_os_type)" in
		nix) nix develop "$@" ;;
		*)
			cwd="$(pwd -P || "${PWD:-.}")"
			arg="${*:-"${cwd}"}"
			cmd="${VISUAL:-${EDITOR:-code}} ${arg}"
			eval "${cmd}" 2>/dev/null || {
				dots__pout --debug "[ERROR] /> dotsrc <\ Failed to run ${cmd}"
				return 1
			}
			dots__pout --debug "[INFO] /> dotsrc <\ Opened ${arg} in ${VISUAL:-${EDITOR:-code}}"
			;;
		esac
	}

	enviro_OLD() {
		#@ Set defaults
		ctx="enviro"
		DELIMITER="${DELIMITER:-"$(printf "\037")"}"
		separator="_"
		OLDIFS="${IFS}" IFS="${DELIMITER}"
		dirs=""
		type="env" shell="bash"
		prefix="" suffix="" key="" val="" env=""
		result=""

		#@ Parse arguments
		while [ "$#" -gt 0 ]; do
			case "$1" in
			--set | --name | --var)
				if [ -n "$2" ]; then
					key="${key:+${key}${DELIMITER}}$2"
				else
					dots__pout --debug "[ERROR] /> ${ctx} <\ Missing argument for" "$1"
					exit 1
				fi
				shift
				;;
			--prefix)
				if [ -n "$2" ]; then
					prefix="${prefix:+${prefix}${DELIMITER}}$2"
				else
					dots__pout --debug "[ERROR] /> ${ctx} <\ Missing argument for" "$1"
					exit 1
				fi
				shift
				;;
			--suffix)
				if [ -n "$2" ]; then
					suffix="${suffix:+${suffix}${DELIMITER}}$2"
				else
					dots__pout --debug "[ERROR] /> ${ctx} <\ Missing argument for" "$1"
					exit 1
				fi
				shift
				;;
			--sh | --shell)
				if [ -n "$2" ]; then
					shell="$2"
				else
					dots__pout --debug "[ERROR] /> ${ctx} <\ Missing argument for" "$1"
					exit 1
				fi
				shift
				;;
			--sep*)
				if [ -n "$2" ]; then
					separator="$2"
				else
					dots__pout --debug "[ERROR] /> ${ctx} <\ Missing argument for" "$1"
					exit 1
				fi
				shift
				;;
			--cmd*)
				type="cmd"
				if [ -n "$2" ]; then
					val="${val:+${val}${DELIMITER}}$2"
					shift
				else
					dots__pout --debug "[ERROR] /> ${ctx} <\ Missing argument for --cmd"
					exit 1
				fi
				;;
			--env*)
				type="env"
				if [ -n "$2" ]; then
					val="${val:+${val}${DELIMITER}}$2"
					shift
				else
					dots__pout --debug "[ERROR] /> ${ctx} <\ Missing argument for --env"
					exit 1
				fi
				;;
			--dir*)
				type="dir"
				if [ -n "$2" ]; then
					val="${val:+${val}${DELIMITER}}$2"
				else
					dots__pout --debug "[ERROR] /> ${ctx} <\ Missing directory name"
				fi
				shift
				;;
			--file*)
				type="file"
				if [ -n "$2" ]; then
					val="${val:+${val}${DELIMITER}}$2"
				else
					dots__pout --debug "[ERROR] /> ${ctx} <\ Missing directory name"
				fi
				shift
				;;
			*)
				val="${val:+${val}${DELIMITER}}$1"
				;;
			esac
			shift
		done

		#@ Define prefix
		if [ -z "${prefix:-}" ]; then :; else
			prefix="$(to_upper "${prefix}")"
			prefix="$(
				swap_DELIMITER "${prefix}" \
					--old "${DELIMITER}" --new "${separator}"
			)"
			dots__pout --debug "/> ${ctx} <\ prefix:" "${prefix}"
		fi

		#@ Define suffix
		if [ -z "${suffix:-}" ]; then :; else
			suffix="$(to_upper "${suffix}")"
			suffix="$(
				swap_DELIMITER "${suffix}" \
					--old "${DELIMITER}" --new "${separator}"
			)"
			dots__pout --debug "/> ${ctx} <\ suffix:" "${suffix}"
		fi

		#@ Define variable name
		if [ -z "${key:-}" ]; then :; else
			key="$(to_upper "${key}")"
			key="$(
				swap_DELIMITER "${key}" \
					--old "${DELIMITER}" --new "${separator}"
			)"
			dots__pout --debug "/> ${ctx} <\ key:" "${key}"
		fi

		#@ Define variable name
		if [ -z "${key:-}" ]; then :; else

			#@ Add prefix
			if [ -z "${prefix:-}" ]; then :; else
				key="${prefix}${separator}${key}"
			fi

			#@ Add suffix
			if [ -z "${suffix:-}" ]; then :; else
				key="${suffix}${separator}${key}"
			fi
			dots__pout --debug "/> ${ctx} <\ key:" "${key}"
		fi

		#@ Define environment pair
		for _val in ${val}; do
			case "${type:-"env"}" in
			cmd)
				#@ Initialize variables
				cmd="${_val}" cmd_key="" cmd_val="" cmd_env=""

				#@ Define the key in uppercase, prefixed with "CMD_"
				cmd_key="$(to_upper "CMD_${cmd}")"
				dots__pout --debug "/> ${ctx} <\ [${cmd}] CMD_KEY: ${cmd_key}"

				#@ Retrieve the path, otherwise return empty string
				cmd_val="$(command -v "${cmd}" 2>/dev/null || printf '')"
				if [ -f "${cmd_val}" ]; then :; else
					case "${cmd_val}" in
					*alias*)
						dots__pout --debug "/> ${ctx} <\ [${cmd}] CMD_ALIAS: ${cmd_val}"
						unalias "${cmd}" &&
							cmd_val="$(command -v "${cmd}" 2>/dev/null || printf '')"
						;;
					*function*)
						#TODO: Add support for functions
						;;
					*) ;;
					esac
				fi
				dots__pout --debug "/> ${ctx} <\ [${cmd}] CMD_VAL: ${cmd_val}"

				#@ Create the export statement
				case "${shell:-"bash"}" in
				sh | bash | zsh)
					cmd_env="$(
						printf "%s=%s\nexport %s" \
							"${cmd_key}" "${cmd_val}" "${cmd_key}"
					)"
					;;
				fish*)
					cmd_env="$(
						printf "set -x %s %s" \
							"${cmd_key}" "${cmd_val}"
					)"
					;;
				nu*)
					cmd_env="$(
						printf "let-env %s = \"%s\"" \
							"${cmd_key}" "${cmd_val}"
					)"
					;;
				pwsh | powershell)
					cmd_env="$(
						printf "\$env:%s = \"%s\"" \
							"${cmd_key}" "${cmd_val}"
					)"
					;;
				*)
					dots__pout --debug "[ERROR] /> ${ctx} <\ Unsupported shell: ${shell}"
					exit 1
					;;
				esac

				#@ Update the environment list
				env="${env:+${env}${DELIMITER}}${cmd_env}"
				;;
			dir)
				#@ Initialize variables
				dir="${_val}" dir_key="" dir_expr=""

				#@ Check if directory exists
				if [ -d "${dir}" ]; then
					dots__pout --debug "/> ${ctx} <\ Directory found: ${dir}"

					#@ Define the key in uppercase, prefixed with "DIR_"
					if [ -z "${key:-}" ]; then
						dir_base="$(basename "${dir}")"
						dir_key="$(to_upper "DIR_${dir_base}")"
					else
						dir_key="${key}"
					fi

					dots__pout --debug "/> ${ctx} <\ [${dir}] DIR_KEY: ${dir_key}"

					#@ Create the export statement
					case "${shell:-"bash"}" in
					sh | bash | zsh)
						dir_expr="$(
							printf "%s=%s\nexport %s" \
								"${dir_key}" "${dir}" "${dir_key}"
						)"
						;;
					fish | f*)
						dir_expr="$(
							printf "set -x %s %s" \
								"${dir_key}" "${dir}"
						)"
						;;
					nu*)
						dir_expr="$(
							printf "let-env %s = \"%s\"" \
								"${dir_key}" "${dir}"
						)"
						;;
					pwsh | powershell | power*)
						dir_expr="$(
							printf "\$env:%s = \"%s\"" \
								"${dir_key}" "${dir}"
						)"
						;;
					*)
						dots__pout --debug "[ERROR] /> ${ctx} <\ Unsupported shell: ${shell}"
						exit 1
						;;
					esac

					#@ Update the environment list
					env="${env:+${env}${DELIMITER}}${dir_expr}"
					dirs="${dirs:+${dirs}${DELIMITER}}${dir}"
				else
					dots__pout --debug "/> ${ctx} <\ Directory not found: ${dir}"
				fi
				;;
			env | *)
				#@ Initialize variables
				env_key="" env_val="${_val}" env_expr=""

				#@ Parse key=value format
				if [ -z "${key:-}" ]; then
					case "${_val}" in
					*=*)
						env_key="${_val%%=*}"
						env_val="${_val#*=}"
						;;
					*)
						env_key="$(to_upper "${_val}")"
						env_val="$(eval printf "%s" "\${${_val}:-}")"
						;;
					esac
				else
					env_key="${key}"
				fi

				dots__pout --debug "/> ${ctx} <\ [${env_key}] ENV_VAL: ${env_val}"

				#@ Create the export statement
				case "${shell:-"bash"}" in
				sh | bash | zsh)
					env_expr="$(
						printf "%s=%s\nexport %s" \
							"${env_key}" "${env_val}" "${env_key}"
					)"
					;;
				fish | f*)
					env_expr="$(
						printf "set -x %s %s" \
							"${env_key}" "${env_val}"
					)"
					;;
				nu*)
					env_expr="$(
						printf "let-env %s = \"%s\"" \
							"${env_key}" "${env_val}"
					)"
					;;
				pwsh | powershell | power*)
					env_expr="$(
						printf "\$env:%s = \"%s\"" \
							"${env_key}" "${env_val}"
					)"
					;;
				*)
					dots__pout --debug "[ERROR] /> ${ctx} <\ Unsupported shell: ${shell}"
					exit 1
					;;
				esac

				#@ Update the environment list
				env="${env:+${env}${DELIMITER}}${env_expr}"
				;;
			esac
		done

		#@ Return the environment list
		result="$(
			for pair in ${env}; do
				printf "%s\n" "${pair}"
				case "${shell:-"bash"}" in
				sh | bash | zsh) printf "\n" ;; *) ;; esac
			done
		)"
		printf "%s" "${result}"
		IFS="${OLDIFS}"
	}

	prj_rust() {
		# possible_dirs=(
		#   "${PRJ_RUST}"
		#   "${PROJECTS}/rust"
		#   "${HOME}/Projects/rust"
		#   "${HOME}/projects/Code/Rust"
		#   "${HOME}/projects/Code/rust"
		# )
		:
	}

	# enviro() {
	# 	enviro__main() {
	# 		enviro__set_local_env
	# 		enviro__parse_arguments "$@"
	# 	}

	# 	enviro__set_local_env() {
	# 		ctx="enviro" ctx_sep="${ctx_sep:-"-|-"}" _ctx=""
	# 		DELIMITER="${DELIMITER:-"$(printf "\037")"}"
	# 		separator="_"
	# 		OLDIFS="${IFS}" IFS="${DELIMITER}"

	# 		#@ Default settings
	# 		action="get"
	# 		shell="$(basename "${SHELL:-"posix"}")"
	# 		order="$(printf "abs|cmd|env" | tr "|" "${DELIMITER}")"
	# 		focus="" _focus=""
	# 		vars=""
	# 		vals=""
	# 		args=""
	# 		result=""
	# 	}

	# 	enviro__parse_arguments() {
	# 		#@ Set context
	# 		ctx_parse="${ctx}${ctx_sep}parse_arguments"

	# 		#@ Parse arguments
	# 		while [ "$#" -ge 1 ]; do
	# 			case "$1" in
	# 			--test)
	# 				enviro__execute_test
	# 				return 0
	# 				;;
	# 			--action)
	# 				if [ -n "$2" ]; then
	# 					action="$2"
	# 					shift
	# 				else
	# 					dots__pout --debug "[WARN] /> ${ctx} <\ Missing argument for '$1'. Using default: ${action}"
	# 				fi
	# 				;;
	# 			--get | --set | --unset | --check)
	# 				action="${1#--}"
	# 				;;
	# 			--shell)
	# 				if [ -n "$2" ]; then
	# 					shell="$2"
	# 					shift
	# 				else
	# 					dots__pout --debug "[WARN] /> ${ctx} <\ Missing argument for '$1'. Using default: ${action}"
	# 				fi
	# 				;;
	# 			--sh | --bash | --zsh | --pwsh | --fish | --nu* | --powershell)
	# 				shell="${1#--}"
	# 				;;
	# 			--type | --focus | --order)
	# 				_ctx="$1"

	# 				#@ Move to first argument after the flag
	# 				shift

	# 				#@ Store all arguments until next flag
	# 				while [ "$#" -ge 1 ]; do
	# 					case "$1" in
	# 					--*) break ;;
	# 					*) _focus="${_focus:+${_focus}${DELIMITER}}$1" ;;
	# 					esac
	# 					shift
	# 				done

	# 				#@ Process stored focus args
	# 				IFS="${DELIMITER}"
	# 				for item in ${_focus}; do
	# 					case "${item}" in
	# 					cmd | env | dir | path | file | link | abs)
	# 						focus="${focus:+${focus}${DELIMITER}}${item}"
	# 						;;
	# 					*)
	# 						#@ Prepend invalid args to maintain original order
	# 						set -- "${item}" "$@"
	# 						;;
	# 					esac
	# 				done

	# 				#@ Cleanup
	# 				IFS="${OLDIFS}"
	# 				_focus=""

	# 				#@ Skip the final shift
	# 				continue
	# 				;;
	# 			--cmd | cmd | command | --env | env | --dir | dir | --path | path | --file | file | --link | link | --abs | abs)
	# 				focus="${focus:+${focus}${DELIMITER}}${1#--}"
	# 				;;
	# 			--var* | --key*)
	# 				if [ -n "$2" ]; then
	# 					vars="$2"
	# 					shift 2
	# 				else
	# 					dots__pout --debug "[ERROR] /> ${ctx} <\ Missing argument for $1"
	# 					return 1
	# 				fi
	# 				;;
	# 			--val*)
	# 				if [ -n "$2" ]; then
	# 					vals="$2"
	# 					shift 2
	# 				else
	# 					dots__pout --debug "[ERROR] /> ${ctx} <\ Missing argument for $1"
	# 					return 1
	# 				fi
	# 				;;
	# 			*)
	# 				args="${args:+${args}${DELIMITER}}$1"
	# 				;;
	# 			esac
	# 			shift
	# 		done

	# 		#@ Update the variables and values based on the action
	# 		case "${action}" in
	# 		set)
	# 			if [ -z "${args}" ]; then :; else
	# 				for arg in ${args}; do
	# 					if [ -z "${vars}" ]; then
	# 						vars="${arg}"
	# 					else
	# 						vals="${vals:+${vals}${DELIMITER}}${arg}"
	# 					fi
	# 				done
	# 			fi
	# 			;;
	# 		check)
	# 			#TODO: Implement behavior for 'check'
	# 			;;
	# 		get | unset | *)
	# 			#@ Convert vals to vars
	# 			vars="${vars:+${vars}${DELIMITER}}${vals}"

	# 			#@ Add args as vars
	# 			if [ -z "${args}" ]; then :; else
	# 				for arg in ${args}; do
	# 					vars="${vars:+${vars}${DELIMITER}}${arg}"
	# 				done
	# 			fi
	# 			;;
	# 		esac

	# 		#@ Debug arguments
	# 		dots__pout --debug "/> ${ctx_parse} <\  FOCUS:" "$(
	# 			printf "%s" "${focus:-"${order}"}" |
	# 				tr "${DELIMITER}" "|" || true
	# 		)"
	# 		dots__pout --debug "/> ${ctx_parse} <\  SHELL:" "${shell}"
	# 		dots__pout --debug "/> ${ctx_parse} <\ ACTION:" "${action}"
	# 		dots__pout --debug "/> ${ctx_parse} <\   VARS:" "[$(
	# 			#@ Set the DELIMITER
	# 			old_ifs="${IFS}"
	# 			IFS="${DELIMITER}"

	# 			#@ Count the variables
	# 			count_tot=0
	# 			for item in ${vars}; do
	# 				count_tot=$((count_tot + 1))
	# 			done

	# 			#@ Print the variables
	# 			count_per=0
	# 			for item in ${vars}; do
	# 				count_per=$((count_per + 1))
	# 				printf " %s of %s: \"%s\" " "${count_per}" "${count_tot}" "${item}"
	# 			done

	# 			#@ Reset the DELIMITER
	# 			IFS="${old_ifs}"
	# 		)]"
	# 		dots__pout --debug "/> ${ctx_parse} <\   VALS:" "$(
	# 			printf "\"%s\"" "${val:-}" |
	# 				tr "${DELIMITER}" " " || true
	# 		)"
	# 	}

	# 	enviro__execute_test() {
	# 		#@ Set context
	# 		ctx_test="${ctx}${ctx_sep}execute_test"

	# 		# dots__pout --test --ctx "${ctx_test}" --cmd "enviro pop --type abs --val \"love\" --bash cmd \"jahjah city\" --key \"kez\" on --type cmd --nu lol"
	# 		dots__pout --ctx "${ctx_test}" --test \
	# 			enviro --type env abs --val pop cmd --shell nu link --file --action set path --key lock
	# 		dots__pout --ctx "${ctx_test}" --test --
	# 		# enviro pop --type abs --val "love" --bash cmd "jahjah city" --key "kez" on --type cmd --nu lol
	# 		# enviro --type env abs --val pop cmd --shell nu link --file --action set path --key lock

	# 		# enviro --cmd "cmd" command --type cmd file --env env --dir dir --path path --file file --link link --abs abs
	# 		return
	# 		# Get command path (all these do the same)
	# 		enviro --cmd fd
	# 		echo
	# 		enviro --get fd
	# 		echo
	# 		enviro fd
	# 		echo

	# 		# Get environment variable
	# 		enviro USER
	# 		echo
	# 		enviro --env USER

	# 		printf "\n\n%s\n" "SET COMMANDS"
	# 		enviro --cmd fd --shell bah --set
	# 		echo
	# 		enviro --cmd fd --shell pwsh --set
	# 		echo
	# 		enviro --cmd fd --shell fish --set
	# 		echo
	# 		enviro --cmd fd --shell nushell --set
	# 		# Output: CMD_FD=/path/to/fd\nexport CMD_FD

	# 		printf "\n\n%s\n" "GET VARIABLES"
	# 		#TODO: This should generate the necessary get command for the appropriate shell. It's not just about returning the command. Remember if the --shell flag is set it means it will be used in that situation
	# 		enviro --get --env USER --shell pwsh
	# 		# Output: C:\Users\Administrator

	# 		printf "\n\n%s\n" "SET VARIABLES"
	# 		# Set custom env var in PowerShell
	# 		enviro --env myvar --set craole --shell pwsh
	# 		# Output: $env:USER = "craole"

	# 		printf "\n\n%s\n" "UPDATE PATH"
	# 		enviro --path --set /usr/local/bin

	# 		printf "\n\n%s\n" "CHECK PATH"
	# 		enviro --path --check /usr/local/bin

	# 		printf "\n\n%s\n" "GET ABS PATH"
	# 		enviro --abs ~/.config
	# 		echo
	# 		enviro --abs "${HOME}"

	# 		printf "\n\n%s\n" "SET DIR"
	# 		enviro --dir /usr/local --set LOCAL_DIR
	# 		echo

	# 		# enviro --cmd rustc cargo fd pop ls --shell pwsh
	# 		# enviro --cmd fd --shell bash
	# 		# enviro --env USER --shell pwsh
	# 		# enviro \
	# 		#   "${HOME}/Projects/Code/Rust" \
	# 		#   --name rust \
	# 		#   "${PRJ_RUST:-}" \
	# 		#   --prefix prj \
	# 		#   --prefix for \
	# 		#   --prefix work \
	# 		#   "${HOME}/Projects/rust"
	# 	}

	# 	enviro__execute_core() {
	# 		# @Extract the shell basename without path
	# 		shell_name="$(basename "${shell}")"
	# 		case "${shell_name}" in
	# 		*fish*) shell_type="fish" ;;
	# 		*nu*) shell_type="nushell" ;;
	# 		*pwsh | *powershell) shell_type="powershell" ;;
	# 		*sh | *) shell_type="posix" ;;
	# 		esac

	# 		dots__pout --debug "/> ${ctx} <\ Action: ${action}, Shell: ${shell_name} (${shell_type}), Type: ${type}, Key: ${key}, Val: ${val}"

	# 		# Process based on action
	# 		case "${action:-get}" in
	# 		set)
	# 			# Set requires a key and value
	# 			if [ -z "${key}" ]; then
	# 				dots__pout --debug "[ERROR] /> ${ctx} <\ Missing key for --set"
	# 				return 1
	# 			fi

	# 			# If type is not specified but val is empty, try to autodetect
	# 			if [ -z "${type}" ] && [ -z "${val}" ]; then
	# 				# Try to find what key refers to
	# 				if command -v "${key}" >/dev/null 2>&1; then
	# 					type="cmd"
	# 					val="$(command -v "${key}")"
	# 				elif [ -d "${key}" ]; then
	# 					type="dir"
	# 					val="${key}"
	# 				elif [ -f "${key}" ]; then
	# 					type="file"
	# 					val="${key}"
	# 				elif [ -L "${key}" ]; then
	# 					type="link"
	# 					val="${key}"
	# 				else
	# 					# Default to env
	# 					type="env"
	# 					val="${key}"
	# 				fi
	# 			fi

	# 			# Default val to key if not specified
	# 			if [ -z "${val}" ]; then
	# 				val="${key}"
	# 			fi

	# 			# Generate appropriate export syntax
	# 			case "${type}" in
	# 			cmd)
	# 				# For commands, prefix with CMD_
	# 				cmd_path="$(command -v "${key}" 2>/dev/null || echo "${val}")"
	# 				env_key="CMD_$(echo "${key}" | tr '[:lower:]' '[:upper:]')"

	# 				case "${shell_type}" in
	# 				posix)
	# 					result="${env_key}=${cmd_path}\nexport ${env_key}"
	# 					;;
	# 				fish)
	# 					result="set -x ${env_key} ${cmd_path}"
	# 					;;
	# 				nushell)
	# 					result="let-env ${env_key} = \"${cmd_path}\""
	# 					;;
	# 				powershell)
	# 					result="\$env:${env_key} = \"${cmd_path}\""
	# 					;;
	# 				*) ;;
	# 				esac
	# 				;;

	# 			dir)
	# 				# For directories, prefix with DIR_ if no custom key
	# 				if [ "${key}" = "${val}" ]; then
	# 					# Auto-generate key from directory name
	# 					dir_name="$(basename "${key}")"
	# 					env_key="DIR_$(echo "${dir_name}" | tr '[:lower:]' '[:upper:]')"
	# 				else
	# 					env_key="$(echo "${key}" | tr '[:lower:]' '[:upper:]')"
	# 				fi

	# 				case "${shell_type}" in
	# 				posix)
	# 					result="${env_key}=${val}\nexport ${env_key}"
	# 					;;
	# 				fish)
	# 					result="set -x ${env_key} ${val}"
	# 					;;
	# 				nushell)
	# 					result="let-env ${env_key} = \"${val}\""
	# 					;;
	# 				powershell)
	# 					result="\$env:${env_key} = \"${val}\""
	# 					;;
	# 				*) ;;
	# 				esac
	# 				;;

	# 			file)
	# 				# For files, prefix with FILE_ if no custom key
	# 				if [ "${key}" = "${val}" ]; then
	# 					# Auto-generate key from file name
	# 					file_name="$(basename "${key}")"
	# 					env_key="FILE_$(echo "${file_name}" | tr '[:lower:]' '[:upper:]')"
	# 				else
	# 					env_key="$(echo "${key}" | tr '[:lower:]' '[:upper:]')"
	# 				fi

	# 				case "${shell_type}" in
	# 				posix)
	# 					result="${env_key}=${val}\nexport ${env_key}"
	# 					;;
	# 				fish)
	# 					result="set -x ${env_key} ${val}"
	# 					;;
	# 				nushell)
	# 					result="let-env ${env_key} = \"${val}\""
	# 					;;
	# 				powershell)
	# 					result="\$env:${env_key} = \"${val}\""
	# 					;;
	# 				*) ;;
	# 				esac
	# 				;;

	# 			path)
	# 				# Add to PATH variable
	# 				case "${shell_type}" in
	# 				posix)
	# 					result="PATH=${val}:\${PATH}\nexport PATH"
	# 					;;
	# 				fish)
	# 					result="set -x PATH ${val} \$PATH"
	# 					;;
	# 				nushell)
	# 					result="let-env PATH = \"${val}:\${env.PATH}\""
	# 					;;
	# 				powershell)
	# 					result="\$env:Path = \"${val};\$env:Path\""
	# 					;;
	# 				*) ;;
	# 				esac
	# 				;;

	# 			env | *)
	# 				# For environment variables, use as is
	# 				env_key="$(echo "${key}" | tr '[:lower:]' '[:upper:]')"

	# 				case "${shell_type}" in
	# 				posix)
	# 					result="${env_key}=${val}\nexport ${env_key}"
	# 					;;
	# 				fish)
	# 					result="set -x ${env_key} ${val}"
	# 					;;
	# 				nushell)
	# 					result="let-env ${env_key} = \"${val}\""
	# 					;;
	# 				powershell)
	# 					result="\$env:${env_key} = \"${val}\""
	# 					;;
	# 				*) ;;
	# 				esac
	# 				;;
	# 			esac
	# 			;;

	# 		unset)
	# 			# Unset requires a key
	# 			if [ -z "${key}" ]; then
	# 				dots__pout --debug "[ERROR] /> ${ctx} <\ Missing key for --unset"
	# 				return 1
	# 			fi

	# 			case "${type}" in
	# 			cmd)
	# 				env_key="CMD_$(echo "${key}" | tr '[:lower:]' '[:upper:]')"
	# 				;;
	# 			dir)
	# 				case "${key}" in DIR_*) ;; *) key="DIR_${key}" ;; esac
	# 				env_key="DIR_$(echo "${key}" | tr '[:lower:]' '[:upper:]')"
	# 				;;
	# 			file)
	# 				env_key="FILE_$(echo "${key}" | tr '[:lower:]' '[:upper:]')"
	# 				;;
	# 			*)
	# 				env_key="$(echo "${key}" | tr '[:lower:]' '[:upper:]')"
	# 				;;
	# 			esac
	# 			# If type is cmd, prepend CMD_
	# 			if [ "${type}" = "cmd" ]; then
	# 				env_key="CMD_$(echo "${key}" | tr '[:lower:]' '[:upper:]')"
	# 			elif [ "${type}" = "dir" ]; then
	# 				if [ "${key}" != DIR_* ]; then
	# 					env_key="DIR_$(echo "${key}" | tr '[:lower:]' '[:upper:]')"
	# 				else
	# 					env_key="$(echo "${key}" | tr '[:lower:]' '[:upper:]')"
	# 				fi
	# 			elif [ "${type}" = "file" ]; then
	# 				if [[ "${key}" != FILE_* ]]; then
	# 					env_key="FILE_$(echo "${key}" | tr '[:lower:]' '[:upper:]')"
	# 				else
	# 					env_key="$(echo "${key}" | tr '[:lower:]' '[:upper:]')"
	# 				fi
	# 			else
	# 				env_key="$(echo "${key}" | tr '[:lower:]' '[:upper:]')"
	# 			fi

	# 			# Generate unset command
	# 			case "${shell_type}" in
	# 			posix)
	# 				result="unset ${env_key}"
	# 				;;
	# 			fish)
	# 				result="set -e ${env_key}"
	# 				;;
	# 			nushell)
	# 				result="hide-env ${env_key}"
	# 				;;
	# 			powershell)
	# 				result="Remove-Item env:${env_key} -ErrorAction SilentlyContinue"
	# 				;;
	# 			esac
	# 			;;

	# 		check)
	# 			# Check if a path exists in PATH
	# 			if [ -z "${key}" ]; then
	# 				dots__pout --debug "[ERROR] /> ${ctx} <\ Missing path to check"
	# 				return 1
	# 			fi

	# 			# Get PATH and check
	# 			path_found="0"
	# 			IFS=":"
	# 			for path_item in ${PATH}; do
	# 				IFS="${OLDIFS}"
	# 				if [ "${path_item}" = "${key}" ]; then
	# 					path_found="1"
	# 					break
	# 				fi
	# 			done
	# 			IFS="${OLDIFS}"

	# 			if [ "${path_found}" = "1" ]; then
	# 				result="true"
	# 			else
	# 				result="false"
	# 			fi
	# 			;;
	# 		get | *)
	# 			# If no type specified, try to detect using search_order
	# 			if [ -z "${type}" ]; then
	# 				IFS=":"
	# 				for search_type in ${search_order}; do
	# 					IFS="${OLDIFS}"
	# 					dots__pout --debug "/> ${ctx} <\ Trying type: ${search_type} for ${key}"

	# 					case "${search_type}" in
	# 					cmd)
	# 						# Check if it's a command
	# 						cmd_val="$(command -v "${key}" 2>/dev/null || true)"
	# 						if [ -n "${cmd_val}" ]; then
	# 							result="${cmd_val}"
	# 							break
	# 						fi
	# 						;;
	# 					abs)
	# 						# Check if it's an absolute path
	# 						if [ -e "${key}" ]; then
	# 							if [ -d "${key}" ]; then
	# 								# It's a directory
	# 								result="${key}"
	# 								break
	# 							elif [ -f "${key}" ]; then
	# 								# It's a file
	# 								result="${key}"
	# 								break
	# 							elif [ -L "${key}" ]; then
	# 								# It's a symlink
	# 								result="${key}"
	# 								break
	# 							fi
	# 						fi
	# 						;;
	# 					env)
	# 						# Check if it's an environment variable - try uppercase first
	# 						env_key_upper="$(echo "${key}" | tr '[:lower:]' '[:upper:]')"
	# 						env_val="$(eval echo "\${${env_key_upper}:-}")"

	# 						if [ -n "${env_val}" ]; then
	# 							result="${env_val}"
	# 							break
	# 						fi

	# 						# Try original case
	# 						env_val="$(eval echo "\${${key}:-}")"
	# 						if [ -n "${env_val}" ]; then
	# 							result="${env_val}"
	# 							break
	# 						fi
	# 						;;
	# 					path)
	# 						# TODO: use grep or case to check for the exact val in PATH. Remember it could be at the front, back or in the middle so user ":" appropriately
	# 						;;
	# 					*)
	# 						#TODO: We need search type order as well, so if the search type is not defined the default order should be cmd:env:abs. Ourder can also be user-defined.
	# 						;;
	# 					esac
	# 				done
	# 				IFS="${OLDIFS}"
	# 			else
	# 				# Specific type was requested
	# 				case "${type}" in
	# 				cmd)
	# 					result="$(command -v "${key}" 2>/dev/null || true)"
	# 					;;
	# 				dir)
	# 					if [ -d "${key}" ]; then
	# 						result="${key}"
	# 					else
	# 						result=""
	# 					fi
	# 					;;
	# 				file)
	# 					if [ -f "${key}" ]; then
	# 						result="${key}"
	# 					else
	# 						result=""
	# 					fi
	# 					;;
	# 				link)
	# 					if [ -L "${key}" ]; then
	# 						result="${key}"
	# 					else
	# 						result=""
	# 					fi
	# 					;;
	# 				abs)
	# 					# Return absolute path
	# 					if [ -e "${key}" ]; then
	# 						# Get absolute path
	# 						if command -v realpath >/dev/null 2>&1; then
	# 							result="$(realpath "${key}")"
	# 						elif command -v readlink >/dev/null 2>&1; then
	# 							result="$(readlink -f "${key}" 2>/dev/null || echo "${key}")"
	# 						else
	# 							# Fallback to a more portable but less reliable method
	# 							current_dir="$(pwd)"
	# 							cd "$(dirname "${key}")" 2>/dev/null || {
	# 								result="${key}"
	# 								return
	# 							}
	# 							dir_path="$(pwd)"
	# 							cd "${current_dir}" || true
	# 							result="${dir_path}/$(basename "${key}")"
	# 						fi
	# 					else
	# 						result=""
	# 					fi
	# 					;;
	# 				path)
	# 					# Return PATH with each entry on a new line
	# 					if [ -z "${key}" ] || [ "${key}" = "PATH" ] || [ "${key}" = "Path" ]; then
	# 						case "${shell_type}" in
	# 						posix)
	# 							result="$(echo "${PATH}" | tr ':' '\n')"
	# 							;;
	# 						fish)
	# 							result="$(echo "${PATH}" | tr ':' '\n')"
	# 							;;
	# 						nushell)
	# 							result="$(echo "${PATH}" | tr ':' '\n')"
	# 							;;
	# 						powershell)
	# 							# For PowerShell, we can't easily get the PATH here
	# 							# Just echo the POSIX PATH as a fallback
	# 							result="$(echo "${PATH}" | tr ':' '\n')"
	# 							;;
	# 						esac
	# 					else
	# 						# Get a specific path variable
	# 						env_val="$(eval echo "\${${key}:-}")"
	# 						result="$(echo "${env_val}" | tr ':' '\n')"
	# 					fi
	# 					;;
	# 				env)
	# 					# First try uppercase
	# 					env_key_upper="$(echo "${key}" | tr '[:lower:]' '[:upper:]')"
	# 					env_val="$(eval echo "\${${env_key_upper}:-}")"

	# 					if [ -n "${env_val}" ]; then
	# 						result="${env_val}"
	# 					else
	# 						# Try original case
	# 						env_val="$(eval echo "\${${key}:-}")"
	# 						result="${env_val}"
	# 					fi
	# 					;;
	# 				esac
	# 			fi
	# 			;;
	# 		esac

	# 		# Output the result
	# 		printf "%s" "${result}"
	# 		return 0
	# 	}

	# 	enviro__main "$@"
	# }

}

dots__init_aliases() {
	fl() {
		if [ -x "${CMD_EZA:-}" ]; then
			\eza \
				--long \
				--almost-all \
				--group-directories-first \
				--show-symlinks \
				--icons auto \
				--colour auto \
				--colour-scale \
				--colour-scale-mode gradient \
				--git \
				--time-style relative \
				--total-size \
				--smart-group \
				"$@"
		elif [ -x "${CMD_LSD:-}" ]; then
			\lsd \
				--long \
				--almost-all \
				--group-directories-first \
				--color=always \
				--git \
				--date=relative \
				--versionsort \
				--total-size \
				"$@"
		else
			\ls -lAhF \
				--color=always \
				--group-directories-first \
				"$@"
		fi
	}
	alias l='fl'

	ft() {
		if [ -x "${CMD_EZA:-}" ]; then
			\eza \
				--long \
				--almost-all \
				--group-directories-first \
				--show-symlinks \
				--icons auto \
				--colour auto \
				--colour-scale \
				--colour-scale-mode gradient \
				--git \
				--git-ignore \
				--time-style relative \
				--total-size \
				--smart-group \
				--tree \
				"$@"
		elif [ -x "${CMD_LSD:-}" ]; then
			\lsd --tree "$@"
		else
			\ls --recursive "$@"
		fi
	}
	alias t='ft'

	wat() {
		if [ -x "${CMD_BAT:-}" ]; then
			bat --color=always "$@"
		else
			\cat "$@"
		fi
	}
	alias r='wat'

	red() {
		if [ -x "${CMD_BAT:-}" ]; then
			bat --color=always "$@" --style=plain
		else
			\cat "$@"
		fi
	}
	alias R='red'

}

init_tests() {
	debug=1
	dots__pout --debug "/> dotsrc <\ Tests initialized"
	# enviro --test

	# swap_DELIMITER pop lock --str lol --old "|" --new "*"
	dots__pout --debug "\n/> dotsrc <\ Tests completed"
}

dotsenv_BAD() {
	dotsenv__cleanup() {
		#@ Remove variables from the environment
		unset arg args esc var _var val _val entry
		unset force reset env_type
		unset rc
		IFS="${old_ifs}"
	}
	trap dotsenv__cleanup EXIT HUP INT TERM

	args=""
	esc=""
	arg=""
	var="" _var=""
	val="" _val=""
	entry=""
	force=""
	rc="${RC:-".dotsrc"}"
	editor="${editor:-"${VISUAL:-${EDITOR:-code}}"}"
	env_type=""
	old_ifs="${IFS}"
	IFS="${DELIMITER:-"$(printf "\037")"}"

	#@ Reset the cache, if requested
	case "${reset:-"${RESET:-0}"}" in 1 | yes)
		dots__pout --debug "Resetting the cache:" "${DOTS_CACHE_RC}"
		rm -rf "${DOTS_CACHE_RC}" >/dev/null 2>&1
		;;
	*) ;; esac

	#@ Ensure the cache directory exists
	mkdir -p "${DOTS_CACHE}"

	#@ Initialize the cache, if necessary
	if [ -f "${DOTS_CACHE_RC}" ]; then :; else
		dots__pout --debug "Creating the cache file:" "${DOTS_CACHE_RC}"
		{
			printf "%s\n" "#!/bin/sh"
			printf "%s\n" "# shellcheck enable=all"
			printf "%s\n" "# shellcheck disable=SC1091"
			printf "%s\n" "# >>-DOTS Cache->> ${DOTS_CACHE_RC} <\\"
			printf "%s\n\n" "# Generated at: $(date)"
		} >"${DOTS_CACHE_RC}"
	fi

	#@ If no arguments are provided, simply load the cache
	[ "$#" -lt 0 ] && {
		. "${DOTS_CACHE_RC}"
		dotsenv__cleanup
		return
	}

	#@ Parse arguments
	while [ "$#" -ge 1 ]; do
		case "$1" in
		--force) _force=true ;;
		--dir)
			env_type=dir
			var="$2"
			val="$3"
			shift 2
			;;
		--var) var="$2" ;;
		--val) val="$2" ;;
		--cmd) env_type=cmd ;;
		*)
			case "${OS_TYPE:-"$(fetch_info --os)"}" in
			windows)
				#@ Ensure proper character escaping
				esc="$(printf "%s" "$1" | sed 's/"/\\"/g')"
				args="${args:+${args}${DELIMITER}}\"${esc}\""
				;;
			*)
				#@ Unix-style escaping
				esc="$(printf "%s" "$1" | sed "s/'/'\\\\''/g")"
				args="${args:+${args}${DELIMITER}}'${esc}'"
				;;
			esac
			;;
		esac
		shift
	done

	case "${force}" in true | 1)
		printf "\n%b" "$*" >>"${DOTS_CACHE_RC}"
		dotsenv__cleanup
		return
		;;
	*) ;; esac

	case "${env_type}" in
	dir)
		var="$(to_upper "${var}")"
		val_rc="$(printf "\"%s/%s\"" "${val}" "${rc}")"
		var_rc="$(to_upper "$(printf "%s_RC" "${var}")")"
		var_lcase="$(to_lower "${var}")"
		ln_env="$(printf "%s=\"%s\"" "${var}" "${val}")"
		ln_check="$(printf "if [ ! -d \"%s\" ]; then :; else" "${val}")"
		ln_export="$(printf "export %s" "${var}")"
		ln_alias_cd="$(printf "alias cd.%s='cd \"%s\"'" "${var_lcase}" "${val}")"
		ln_alias_edit="$(printf "alias edit.%s='%s %s'" "${var_lcase}" "${editor}" "${val}")"
		ln_env_rc="$(printf "%s=%s" "${var_rc}" "${val_rc}")"
		ln_check_rc="$(printf "if [ ! -f %s ]; then :; else" "${val_rc}")"
		ln_source_rc="$(printf ". %s" "${val_rc}")"
		ln_export_rc="$(printf "export %s" "${var_rc}")"
		ln_alias_edit_rc="$(printf "alias edit.%s.rc='%s %s'" "${var_lcase}" "${editor}" "${val_rc}")"
		ln_end="$(printf "fi\nfi")"

		entry="$(
			printf "%s\n" "${ln_env}"
			printf "%s\n" "${ln_check}"
			printf "  %s\n" "${ln_alias_cd}"
			printf "  %s\n" "${ln_alias_edit}"
			printf "  %s\n\n" "${ln_export}"
			printf "  %s\n" "${ln_env_rc}"
			printf "  %s\n" "${ln_check_rc}"
			printf "    %s\n" "${ln_alias_edit_rc}"
			printf "    %s\n" "${ln_export_rc}"
			[ "${var_rc}" = "DOTS_RC" ] ||
				printf "    %s\n" "${ln_source_rc}"
			printf "  %s" "${ln_end}"
		)"

		#@ Write entry to the cache
		dots__pout --trace "Entry:" "${entry}"
		printf "\n%s\n\n" "${entry}" >>"${DOTS_CACHE_RC}"
		;;
	cmd)
		for arg in ${args}; do
			cmd="$(to_unquoted "${arg}")"
			dots__pout --trace "cmd:" "${cmd}"

			case "${cmd}" in
			":" | null | "") continue ;; *)
				#@ Define the variable, value, and entry
				var="$(to_upper "CMD_${cmd}")"
				dots__pout --trace "var:" "${var}"

				val="$(command -v "${cmd}" 2>/dev/null || printf "")"
				dots__pout --trace "val:" "${val}"

				entry="$(
					printf "%s=\"%s\"\nexport %s" "${var}" "${val}" "${var}"
				)"
				;;
			esac

			#@ Write entry to the cache
			printf "\n%s\n\n" "${entry}" >>"${DOTS_CACHE_RC}"
		done
		;;
	*)
		#@ Define the entry
		entry="$(printf "%s=\"%s\"\nexport %s" "${var}" "${val}" "${var}")"

		#@ Write entry to the cache
		printf "\n%s\n\n" "${entry}" >>"${DOTS_CACHE_RC}"
		;;
	esac

	#@ Format the cache
	if [ -x "${CMD_SHFMT:-"$(command -v shfmt 2>/dev/null)"}" ]; then
		shfmt --write "${DOTS_CACHE_RC}"
	else
		dots__pout --error "Unable to format the cache as shfmt is not installed."
	fi

	#@ Reload the cache
	. "${DOTS_CACHE_RC}"

	#@ Cleanup
	dotsenv__cleanup
}

dotsenv() {
	dotsenv__cleanup() {
		#@ Remove variables from the environment
		unset arg args esc var _var val _val entry
		unset force reset env_type
		unset rc current_val
		unset DOTS_CACHE_RESET
		IFS="${old_ifs}"
	}
	trap dotsenv__cleanup EXIT HUP INT TERM

	#@ Set defaults
	args=""
	esc=""
	arg=""
	var="" _var=""
	val="" _val=""
	entry=""
	force=""
	rc="${RC:-".dotsrc"}"
	editor="${editor:-"${VISUAL:-${EDITOR:-code}}"}"
	env_type=""
	old_ifs="${IFS}"
	current_val=""
	# reset="${reset:-"${RESET:-0}"}"
	delimiter="${DELIMITER:-"$(printf "\037")"}"
	IFS="${delimiter}"
	CMD_GREP="${CMD_RG:-"$(
		command -v rg 2>/dev/null ||
			command -v grep 2>/dev/null ||
			printf ""
	)"}"

	#@ Ensure the cache directory exists
	if [ -d "${DOTS_CACHE:-}" ]; then :; else
		dots__pout --trace "Creating the cache directory:" "${DOTS_CACHE}"
		mkdir -p "${DOTS_CACHE}"
	fi

	#@ Initialize the cache, if necessary
	if [ -f "${DOTS_CACHE_RC:-}" ]; then
		# dots__pout --trace "Proceeding with existing cache:" "${DOTS_CACHE_RC}"
		:
	else
		dots__pout --debug "Creating the cache file:" "${DOTS_CACHE_RC}"
		{
			printf "%s\n" "#!/bin/sh"
			printf "%s\n" "# shellcheck enable=all"
			printf "%s\n" "# shellcheck disable=SC1091"
			printf "%s\n" "# >>-DOTS Cache->> ${DOTS_CACHE_RC} <\\"
			printf "%s\n\n" "# Generated at: $(date)"
		} >"${DOTS_CACHE_RC}"
	fi

	#@ If no arguments are provided, simply load the cache
	if [ "$#" -eq 0 ]; then
		. "${DOTS_CACHE_RC}"
		dotsenv__cleanup
		return
	else
		# dots__pout --trace "Arguments:" "$*"
		:
	fi

	#@ Parse arguments
	while [ "$#" -ge 1 ]; do
		case "$1" in
		--force) _force=true ;;
		--dir)
			env_type=dir
			var="$2"
			val="$3"
			shift 2
			;;
		--var) var="$2" ;;
		--val) val="$2" ;;
		--cmd) env_type=cmd ;;
		*)
			case "${OS_TYPE:-"$(fetch_info --os)"}" in
			windows)
				#@ Ensure proper character escaping
				esc="$(printf "%s" "$1" | sed 's/"/\\"/g')"
				args="${args:+${args}${delimiter}}\"${esc}\""
				;;
			*)
				#@ Unix-style escaping
				esc="$(printf "%s" "$1" | sed "s/'/'\\\\''/g")"
				args="${args:+${args}${delimiter}}'${esc}'"
				;;
			esac
			;;
		esac
		shift
	done

	unset var_empty var_found
	var_found="$(rg "^${var}=" "${DOTS_CACHE_RC}")"
	var_empty="$(rg "^${var}=\"\"" "${DOTS_CACHE_RC}")"

	if [ -n "${var_found:-}" ]; then
		echo "var found: ${var_found}"
		if [ -z "${var_empty:-}" ]; then
			echo "var_empty: ${var_empty}"
		else
			echo "not empty - skip: ${var}"
		fi
	# rg "^${var}=" "${DOTS_CACHE_RC}"
	else
		echo "not found"
	fi
	# return

	case "${force}" in true | 1)
		printf "\n%b" "$*" >>"${DOTS_CACHE_RC}"
		dotsenv__cleanup
		return
		;;
	*) ;; esac

	case "${env_type}" in
	dir)
		#@ Check if the variable is already set
		var_check="$(to_upper "${var}")"
		if [ -x "${CMD_GREP}" ]; then
			current_var="$(
				# shellcheck disable=SC2016
				${CMD_GREP} "^${var_check}=\"(.*)\"" -r '$1' \
					"${DOTS_CACHE_RC}" 2>/dev/null || printf ""
			)"
		else
			current_var="$(
				grep "^${var_check}=" "${DOTS_CACHE_RC}" 2>/dev/null |
					sed 's/^[^"]*"\([^"]*\)".*/\1/' || printf ""
			)"
		fi
		[ current_var = "${var_check}" ] && {
			dots__pout --trace "Skipping ${var_check}: already set to \"${current_var}\""
			# dotsenv__cleanup
			# return
		}

		dots__pout --trace "Proceeding with var in dir:" "${var_check}"
		# return

		#@ Check if the variable is already set with the same value
		var_check="$(to_upper "${var}")"
		if [ -x "${CMD_GREP}" ]; then
			current_val="$(
				# shellcheck disable=SC2016
				${CMD_GREP} "^${var_check}=\"(.*)\"" -r '$1' \
					"${DOTS_CACHE_RC}" 2>/dev/null || printf ""
			)"
		else
			current_val="$(
				grep "^${var_check}=" "${DOTS_CACHE_RC}" 2>/dev/null |
					sed 's/^[^"]*"\([^"]*\)".*/\1/' || printf ""
			)"
		fi

		#@ Skip if the variable is already set with the same value
		if [ "${current_val}" = "${val}" ]; then
			dots__pout --trace "Skipping ${var_check}: already set to \"${val}\""
			dotsenv__cleanup
			return
		fi

		var="$(to_upper "${var}")"
		val_rc="$(printf "\"%s/%s\"" "${val}" "${rc}")"
		var_rc="$(to_upper "${var}_RC")"

		ln_env="$(printf "%s=\"%s\"" "${var}" "${val}")"
		ln_check="$(printf "if [ ! -d \"%s\" ]; then :; else" "${val}")"
		ln_export="$(printf "export %s" "${var}")"
		ln_alias_cd="$(printf "alias cd.%s='cd \"%s\"'" "${var}" "${val}")"
		ln_alias_edit="$(printf "alias edit.%s='%s %s'" "${var}" "${editor}" "${val}")"
		ln_env_rc="$(printf "%s=%s" "${var_rc}" "${val_rc}")"
		ln_check_rc="$(printf "if [ ! -f %s ]; then :; else" "${val_rc}")"
		ln_source_rc="$(printf ". %s" "${val_rc}")"
		ln_export_rc="$(printf "export %s" "${var_rc}")"
		ln_alias_edit_rc="$(printf "alias edit.%s='%s %s'" "${var_rc}" "${editor}" "${val_rc}")"
		ln_end="$(printf "fi\nfi")"

		entry="$(
			printf "%s\n" "${ln_env}"
			printf "%s\n" "${ln_check}"
			printf "  %s\n" "${ln_alias_cd}"
			printf "  %s\n" "${ln_alias_edit}"
			printf "  %s\n\n" "${ln_export}"
			printf "  %s\n" "${ln_env_rc}"
			printf "  %s\n" "${ln_check_rc}"
			printf "    %s\n" "${ln_alias_edit_rc}"
			printf "    %s\n" "${ln_export_rc}"

			case "${var_rc}" in DOTS_RC | DOTS_CACHE_RC) ;; *)
				printf "    %s\n" "${ln_source_rc}"
				;;
			esac

			printf "  %s" "${ln_end}"
		)"

		#@ Write entry to the cache
		dots__pout --trace "Adding entry for ${var}: \"${val}\""
		printf "\n%s\n\n" "${entry}" >>"${DOTS_CACHE_RC}"
		;;
	cmd)
		for arg in ${args}; do
			cmd="$(to_unquoted "${arg}")"
			dots__pout --trace "cmd:" "${cmd}"

			case "${cmd}" in
			":" | null | "") continue ;; *)
				#@ Define the variable, value
				var="$(to_upper "CMD_${cmd}")"

				#@ Check if the variable is already set
				var_check="$(to_upper "${var}")"
				if [ -x "${CMD_GREP}" ]; then
					current_var="$(
						# shellcheck disable=SC2016
						${CMD_GREP} "^${var_check}=\"(.*)\"" -r '$1' \
							"${DOTS_CACHE_RC}" 2>/dev/null ||
							${CMD_GREP} "^${var_check}=\"\"" -r '$1' \
								"${DOTS_CACHE_RC}" 2>/dev/null ||
							printf ""
					)"
				else
					current_var="$(
						grep "^${var_check}=" "${DOTS_CACHE_RC}" 2>/dev/null |
							sed -E 's/^([^=]*=)"?([^"]*)"?.*/\1\2/' ||
							printf ""
					)"

					echo "VAR in cmd: ${var}"
					return

					[ -z "${current_var}" ] &&
						current_var="${var_check}="
				fi
				[ current_var = "${var_check}" ] && {
					dots__pout --trace "Skipping ${var_check}: already set to \"${current_var}\""
					# dotsenv__cleanup
					# return
				}

				dots__pout --trace "Proceeding with var in cmd:" "${var_check}"
				return

				val="$(command -v "${cmd}" 2>/dev/null || printf "")"

				#@ Check if the variable is already set with the same value
				if [ -x "${CMD_GREP}" ]; then
					current_val="$(
						# shellcheck disable=SC2016
						${CMD_GREP} "^${var_check}=\"(.*)\"" -r '$1' \
							"${DOTS_CACHE_RC}" 2>/dev/null || printf ""
					)"
				else
					current_val="$(
						grep "^${var_check}=" "${DOTS_CACHE_RC}" 2>/dev/null |
							sed 's/^[^"]*"\([^"]*\)".*/\1/' || printf ""
					)"
				fi

				#@ Skip if the variable is already set with the same value
				if [ "${current_val}" = "${val}" ]; then
					dots__pout --trace "Skipping ${var}: already set to \"${val}\""
					continue
				fi

				dots__pout --trace "var:" "${var}"
				dots__pout --trace "val:" "${val}"

				entry="$(
					printf "%s=\"%s\"\nexport %s" "${var}" "${val}" "${var}"
				)"

				#@ Write entry to the cache
				dots__pout --debug "Adding entry for ${var}: \"${val}\""
				printf "\n%s\n" "${entry}" >>"${DOTS_CACHE_RC}"
				;;
			esac
		done
		;;
	*)
		#@ Check if the variable is already set
		var_check="$(to_upper "${var}")"
		if [ -x "${CMD_GREP}" ]; then
			current_var="$(
				# shellcheck disable=SC2016
				${CMD_GREP} "^${var_check}=\"(.*)\"" -r '$1' \
					"${DOTS_CACHE_RC}" 2>/dev/null || printf ""
			)"
		else
			current_var="$(
				grep "^${var_check}=" "${DOTS_CACHE_RC}" 2>/dev/null |
					sed 's/^[^"]*"\([^"]*\)".*/\1/' || printf ""
			)"
		fi
		[ current_var = "${var_check}" ] && {
			dots__pout --trace "Skipping ${var_check}: already set to \"${current_var}\""
			# dotsenv__cleanup
			# return
		}

		dots__pout --trace "Proceeding with var:" "${var_check}"
		return
		# if [ -x "${CMD_RG:-"$(command -v rg 2>/dev/null)"}" ]; then
		#   current_val="$(
		#     ${CMD_RG:-"$(command -v rg 2>/dev/null)"} "^${var}=\"(.*)\"" -r '$1' "${DOTS_CACHE_RC}" 2>/dev/null || echo ""
		#   )"
		# else
		#   current_val="$(
		#     grep "^${var}=" "${DOTS_CACHE_RC}" 2>/dev/null |
		#       sed 's/^[^"]*"\([^"]*\)".*/\1/' || echo ""
		#   )"
		# fi

		#@ Skip if the variable is already set with the same value
		if [ "${current_val}" = "${val}" ]; then
			dots__pout --trace "Skipping ${var}: already set to \"${val}\""
			dotsenv__cleanup
			return
		fi

		#@ Define the entry
		entry="$(printf "%s=\"%s\"\nexport %s" "${var}" "${val}" "${var}")"

		#@ Write entry to the cache
		dots__pout --debug "Adding entry for ${var}: \"${val}\""
		printf "\n%s\n\n" "${entry}" >>"${DOTS_CACHE_RC}"
		;;
	esac

	#@ Format the cache
	if [ -x "${CMD_SHFMT:-"$(command -v shfmt 2>/dev/null)"}" ]; then
		shfmt --write "${DOTS_CACHE_RC}"
	else
		dots__pout --error "Unable to format the cache as shfmt is not installed."
	fi

	#@ Cleanup
	dotsenv__cleanup
}

dotsenv__check() {
	${CMD_GREP} "^${var}=" "${DOTS_CACHE_RC}" //dev/null 2>&1
}

dots__environment() {
	DELIMITER="${DELIMITER:-"$(printf "\037")"}" export DELIMITER
	LANG="$(locale -uU || printf "en_US.UTF-8")" export LANG
	VERBOSITY="${verbosity:-"${VERBOSITY:-3}"}"
	VERBOSITY_QUIET="${verbosity_quiet:-"${VERBOSITY_QUIET:-0}"}"
	VERBOSITY_ERROR="${verbosity_error:-"${VERBOSITY_ERROR:-1}"}"
	VERBOSITY_WARN="${verbosity_warn:-"${VERBOSITY_WARN:-2}"}"
	VERBOSITY_INFO="${verbosity_info:-"${VERBOSITY_INFO:-3}"}"
	VERBOSITY_DEBUG="${verbosity_debug:-"${VERBOSITY_DEBUG:-4}"}"
	VERBOSITY_TRACE="${verbosity_trace:-"${VERBOSITY_TRACE:-5}"}"
	export VERBOSITY VERBOSITY_QUIET VERBOSITY_ERROR VERBOSITY_WARN VERBOSITY_INFO VERBOSITY_DEBUG VERBOSITY_TRACE

	#@ Ensure the integral DOTS variable are set
	DOTS="${DOTS:-"${HOME:-}/.dots"}"
	if [ -d "${DOTS}" ]; then
		alias ".dots"='cd "${DOTS}"'
		alias "cd.dots"='cd "${DOTS}"'
		alias "ed.dots"='ed "${DOTS}"'
	else
		dots__pout --debug "DOTS directory is inaccessible:" "${DOTS}"
		return 1
	fi
	RC="${RC:-".dotsrc"}"
	DOTS_RC="${DOTS_RC:-"${DOTS}/${RC}"}"
	DOTS_CACHE="${DOTS}/.cache"
	DOTS_CACHE_RC="${DOTS_CACHE}/${RC}"

	#@ Load top-level directory variables
	DOTS_BIN="${DOTS_BIN:-"${DOTS}/Bin"}"
	if [ -d "${DOTS_BIN}" ]; then
		#@ Define exports
		alias "cd.dots_bin"='cd "${DOTS_BIN}"'
		alias "ed.dots_bin"='ed "${DOTS_BIN}"'

		#@ Load the rc if it exists
		DOTS_BIN_RC="${DOTS_BIN_RC:-"${DOTS_BIN}/${RC}"}"
		if [ -f "${DOTS_BIN_RC}" ]; then
			. "${DOTS_BIN_RC}"
		else
			dots__pout --debug "Missing run command file:" "${DOTS_BIN_RC}"
		fi
	else
		dots__pout --debug "Inaccessible directory:" "${DOTS_BIN}"
	fi

	#@ Update the cache
	if [ -s "${DOTS_CACHE_RC}" ]; then . "${DOTS_CACHE_RC}"; fi
	[ -n "${CMD_BACON}" ] || set_cmd_env --cmd bacon
	[ -n "${CMD_BASH}" ] || set_cmd_env --cmd bash
	[ -n "${CMD_BAT}" ] || set_cmd_env --cmd bat
	[ -n "${CMD_CARGO}" ] || set_cmd_env --cmd cargo
	[ -n "${CMD_CODE_INSIDERS}" ] || set_cmd_env --cmd code-insiders
	[ -n "${CMD_CODE}" ] || set_cmd_env --cmd code
	[ -n "${CMD_EDITOR}" ] || set_cmd_env --cmd editor --bin "${DOTS}/Bin/shellscript/packages/defaults/editor"
	[ -n "${CMD_EZA}" ] || set_cmd_env --cmd eza
	[ -n "${CMD_FD}" ] || set_cmd_env --cmd fd
	# [ -n "${CMD_FISH}" ] || set_cmd_env --cmd fish
	[ -n "${CMD_FYLS}" ] || set_cmd_env --cmd fyls --bin "${DOTS}/Bin/shellscript/environment/fyls"
	[ -n "${CMD_GITUI}" ] || set_cmd_env --cmd gitui
	[ -n "${CMD_GIT}" ] || set_cmd_env --cmd git
	[ -n "${CMD_HX}" ] || set_cmd_env --cmd hx
	[ -n "${CMD_LSD}" ] || set_cmd_env --cmd lsd
	[ -n "${CMD_NANO}" ] || set_cmd_env --cmd nano
	# [ -n "${CMD_NIX}" ] || set_cmd_env --cmd nix
	# [ -n "${CMD_NIXOS_VERSION}" ] || set_cmd_env --cmd nixos-version
	# [ -n "${CMD_NVIM}" ] || set_cmd_env --cmd nvim
	[ -n "${CMD_NU}" ] || set_cmd_env --cmd nu
	[ -n "${CMD_OH_MY_POSH}" ] || set_cmd_env --cmd oh-my-posh
	[ -n "${CMD_PAGER}" ] || set_cmd_env --cmd pager --bin "${DOTS}/Bin/shellscript/output/pager"
	[ -n "${CMD_PERL}" ] || set_cmd_env --cmd perl
	[ -n "${CMD_POUT_REPEAT}" ] || set_cmd_env --cmd pout-repeat --bin "${DOTS}/Bin/shellscript/output/pout-repeat"
	[ -n "${CMD_POUT}" ] || set_cmd_env --cmd pout --bin "${DOTS}/Bin/shellscript/output/pout"
	[ -n "${CMD_POWERSHELL}" ] || set_cmd_env --cmd powershell
	[ -n "${CMD_PWSH}" ] || set_cmd_env --cmd pwsh
	[ -n "${CMD_RG}" ] || set_cmd_env --cmd rg
	[ -n "${CMD_RUSTC}" ] || set_cmd_env --cmd rustc
	[ -n "${CMD_SHFMT}" ] || set_cmd_env --cmd shfmt
	[ -n "${CMD_STARSHIP}" ] || set_cmd_env --cmd starship
	[ -n "${CMD_STRALT}" ] || set_cmd_env --cmd stralt --bin "${DOTS}/Bin/shellscript/output/stralt"
	[ -n "${CMD_TOKEI}" ] || set_cmd_env --cmd tokei
	[ -n "${CMD_TOPGRADE}" ] || set_cmd_env --cmd topgrade
	[ -n "${CMD_TR}" ] || set_cmd_env --cmd tr
	[ -n "${CMD_VALIDATE}" ] || set_cmd_env --cmd validate --bin "${DOTS}/Bin/shellscript/validators/validate"
	[ -n "${CMD_WATCH}" ] || set_cmd_env --cmd watch
	[ -n "${CMD_WATSH}" ] || set_cmd_env --cmd watsh --bin "${DOTS}/Bin/shellscript/project/watsh"
	# [ -n "${CMD_WGET}" ] || set_cmd_env --cmd wget
	[ -n "${CMD_ZED}" ] || set_cmd_env --cmd zed
	# [ -n "${CMD_ZEDITOR}" ] || set_cmd_env --cmd zeditor
	[ -n "${CMD_ZIG}" ] || set_cmd_env --cmd zig
	# [ -n "${CMD_ZSH}" ] || set_cmd_env --cmd zsh
	if [ -s "${DOTS_CACHE_RC}" ]; then
		#@ Format and sorth the variables in the cache rc
		format_rc "${DOTS_CACHE_RC}"

		#@ Reload the cache rc
		. "${DOTS_CACHE_RC}"
		dots__pout --trace "Cache reloaded."
	fi

	#@ Set the editor
	if [ -x "${CMD_EDITOR}" ]; then
		EDITOR_GUI="${editors_gui}"
		EDITOR_TUI="${editors_tui}"
		export EDITOR_GUI EDITOR_TUI

		EDITOR="$("${CMD_EDITOR}" --set)"
		export EDITOR
	fi

	# case "${reset_cache:-0}" in
	# 1 | yes | true)
	#   case "${DOTS_CACHE_STAGE:-"off"}" in
	#   initialized)
	#     dots__pout --trace "DOTS_CACHE_STAGE [init]:" "${DOTS_CACHE_STAGE}"
	#     dots__pout --debug "Loading the cache."
	#     [ -f "${DOTS_CACHE_RC}" ] && . "${DOTS_CACHE_RC}"

	#     #@ Advance the cache stage
	#     export DOTS_CACHE_STAGE="loaded"
	#     ;;
	#   loaded)
	#     dots__pout --trace "DOTS_CACHE_STAGE [loaded]:" "${DOTS_CACHE_STAGE}"
	#     dots__pout --debug "Cache already loaded."

	#     #@ Reload the cache
	#     # [ -f "${DOTS_CACHE_RC}" ] && . "${DOTS_CACHE_RC}"
	#     # dots__pout --debug "Cache reloaded."
	#     ;;
	#   off | *)
	#     dots__pout --trace "DOTS_CACHE_STAGE [off|*]:" "${DOTS_CACHE_STAGE}"
	#     #@ Set the initial cache stage
	#     export DOTS_CACHE_STAGE=off

	#     #@ Ensure the cache directory exists
	#     mkdir -p "${DOTS_CACHE}"

	#     #@ Remove the cache
	#     rm -f "${DOTS_CACHE_RC}" >/dev/null 2>&1

	#     #@ Initialize the cache
	#     dots__pout --debug "Initializing the cache..."
	#     dots__cache_init
	#     [ -f "${DOTS_CACHE_RC}" ] && . "${DOTS_CACHE_RC}"

	#     #@ Advance the cache stage
	#     export DOTS_CACHE_STAGE="initialized"

	#     dots__pout --trace "DOTS_CACHE_STAGE [off|*]:" "${DOTS_CACHE_STAGE}"
	#     dots__pout --debug "Cache already loaded."

	#     #@ Reload the cache
	#     [ -f "${DOTS_CACHE_RC}" ] && . "${DOTS_CACHE_RC}"
	#     dots__pout --debug "Cache reloaded."
	#     ;;
	#   esac
	#   ;;
	# *)
	#   dots__pout --debug "Reset off. Loading the cache."
	#   [ -f "${DOTS_CACHE_RC}" ] && . "${DOTS_CACHE_RC}"
	#   dots__cache_init
	#   [ -f "${DOTS_CACHE_RC}" ] && . "${DOTS_CACHE_RC}"

	#   #@ Advance the cache stage
	#   DOTS_CACHE_STAGE="loaded"
	#   ;;
	# esac

	# dots__pout --trace "DOTS_CACHE_STAGE [after]:" "${DOTS_CACHE_STAGE}"

	# [ -f "${DOTS_CACHE_RC}" ] && . "${DOTS_CACHE_RC}"

	dots__cache_init() {
		#@ Define the global environment variables
		#| Core Info
		# dotsenv --var OS_TYPE --val "$(fetch_info --os)"
		# dotsenv --var USER --val "$(fetch_info --user)"

		# #| Verbosity & Printing
		# dotsenv --var DELIMITER --val "$(printf "\037")"
		# dotsenv --var VERBOSITY_QUIET --val 0
		# dotsenv --var VERBOSITY_WARN --val 1
		# dotsenv --var VERBOSITY_ERROR --val 2
		# dotsenv --var VERBOSITY_INFO --val 3
		# dotsenv --var VERBOSITY_DEBUG --val 4
		# dotsenv --var VERBOSITY_TRACE --val 5

		# #| Commands
		# dotsenv --cmd \
		#   bacon \
		#   :
		# bash \
		# bat \
		# cargo \
		# code \
		# eza \
		# fd \
		# fish \
		# hx \
		# lsd \
		# nu \
		# pathman \
		# pwsh \
		# python3 \
		# rg \
		# rustc \
		# sh \
		# shfmt \
		# starship \
		# tldr \
		# tokei \
		# topgrade \
		# watch \
		# zig \
		# zoxide \
		# zsh \

		# #| DOTS
		# dotsenv --dir DOTS "${DOTS}"
		dotsenv --dir DOTS_BIN "${DOTS}/Bin"
		dotsenv --dir CMD_RG "/c/Users/Administrator/AppData/Local/Microsoft/WinGet/Links/rg"
		dotsenv --dir CMD_GR ""
		# dotsenv --dir DOTS_CFG "${DOTS}/Configuration"
		# dotsenv --dir DOTS_ENV "${DOTS}/Environment"
		# dotsenv --dir DOTS_DOC "${DOTS}/Documentation"
		# dotsenv --dir DOTS_DLD "${DOTS}/Downloads"
		# dotsenv --dir DOTS_MOD "${DOTS}/Modules"
		# dotsenv --dir DOTS_RES "${DOTS}/Resources"
		# dotsenv --dir DOTS_JOB "${DOTS}/TODO"
		# dotsenv --var DOTS_ACTIVE_APPS --val "${DOTS_CACHE}/apps.log"

		# #| Projects
		if [ -n "${PRJ}" ]; then
			dotsenv --dir PRJ "${PRJ}"
		elif [ -d "${HOME}/Projects" ]; then
			dotsenv --dir PRJ "${HOME}/Projects"
		elif
			: ||
				[ -d "${HOME}/Documents/GitLab" ] ||
				[ -d "${HOME}/Documents/Gitlab" ] ||
				[ -d "${HOME}/Documents/gitlab" ] ||
				[ -d "${HOME}/Documents/GitHub" ] ||
				[ -d "${HOME}/Documents/Github" ] ||
				[ -d "${HOME}/Documents/github" ]
		then
			dotsenv --dir PRJ "${HOME}/Documents"
		else
			dotsenv --dir PRJ "${DOTS}/../Projects"
		fi

		#| Scripts
		# pathman="${DOTS}/Bin/shellscript/environment/pathman"
		# [ -z "${CMD_PATHMAN}" ] && [ -x "${pathman}" ] &&
		#   dotsenv --var CMD_PATHMAN --val "${pathman}"
	}

	# dots__cache_init
	#@ Reload the cache
	# [ -f "${DOTS_CACHE_RC}" ] && . "${DOTS_CACHE_RC}"
	# dots__pout --debug "Cache reloaded."
}

main "$@"
