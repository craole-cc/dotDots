#!/bin/sh

# Outputs log messages to console and/or file with various formatting options.
# Arguments:
#   --quiet            Suppress output.
#   --error            Mark message as error level.
#   --warn             Mark message as warning level.
#   --info             Mark message as info level.
#   --debug            Mark message as debug level.
#   --trace            Mark message as trace level.
#   --key <string>     Key for key-value pair in message.
#   --val <string>     Value for key-value pair in message.
#   --sep <string>     Separator for key-value pair.
#   --lead <integer>   Number of leading blank lines.
#   --trail <integer>  Number of trailing blank lines.
#   --end             Ensure message is the last line output.
#   --pad              Pad key-value pair for aligned output.
#   --hide-level       Hide verbosity level in message.
#   --hide-timestamp   Hide timestamp in message.
#   --no-log           Do not log the message to a file.
#   --log <file>       Log message to specified file.
#   --msg <string>     Specify message to output.
# Returns:
#   0 - Success
#   1 - Failure (invalid arguments or options)

main() {
	trap 'purge_environment' EXIT
	set_defaults
	parse_arguments "$@"
	execute_process
}

purge_environment() {
	#@ Establish defaults
	unset msg key val
	unset lvl hide_lvl
	unset ln_lead ln_trail
	unset pad sep
	unset log
	unset hide_time
	unset target
	unset ln_line
}

set_defaults() {
	purge_environment
	ln_lead=0
	ln_trail=1
	delimiter="$(printf '\006')"
	target="console${delimiter}log"
}

is_number() {
	# validate --integer "$2" >/dev/null 2>&1
	[ "$1" -eq "$1" ] 2>/dev/null
}
# sep="${__sep:-": "}"
# padding="${__pad:-36}"
# log="$DOTS_LOG_DOTS"
parse_arguments() {

	#@ Parse arguments
	while [ "$#" -gt 0 ]; do
		case $1 in
		-h) show_info --usage ;;
		--help) show_info --help ;;
		-v | --version) show_info --version ;;
		--quiet | --error | --warn | --info | --debug | --trace)
			lvl=${1#--}
			ln_trail=1
			;;
		--hide-l*) hide_lvl=true ;;
		--hide-t*) hide_time=true ;;
		--hide-console | --log-only | --no-output | --no-print) target="log" ;;
		--no-log | --print | --console-only) target="console" ;;
		-L | --log)
			[ "$2" ] && {
				validate_file --parent "$2" || return 1
				log="$2"
				shift
			}
			;;
		-b | -ll | --line-l* | --lead*l*)
			if [ "$2" ] && is_number "$2"; then
				ln_lead="$2"
				shift
			else
				ln_lead=1
			fi
			;;
		-n | -lt | --line-t* | --lead*t*)
			if is_number "$2"; then
				ln_trail="$2"
				shift
			else
				ln_trail=1
			fi
			;;
		--key)
			if [ "$2" ]; then
				key="$2"
				shift
			else
				pout --error "No key provided to --key"
				return 1
			fi
			;;
		--val)
			if [ "$2" ]; then
				val="$2"
				shift
			else
				val="{ Missing Value }"
				val_fmt="${FMT_RED}${val}${FMT_NORMAL}"
			fi
			;;
		--sep*)
			if [ "$2" ]; then
				sep="$2"
				shift
			else
				pout --error "No separator provided to --sep"
				return 1
			fi
			;;
		-z | --end | --last*)
			end=true
			;;
		--pad)
			pad=true
			[ "$2" ] && valid_number "$2" && {
				pad="$2"
				shift
			}
			;;
		--delimiter)
			list_delimiter="$2"
			shift
			;;
		-m | --msg | --message)
			[ "$2" ] && {
				if [ "$msg" ]; then
					msg="${msg}${delimiter}${2}"
				else
					msg="$2"
				fi
				shift
			}
			;;
		*)
			if [ "$msg" ]; then
				msg="$msg $1"
			else
				msg="$1"
			fi
			;;
		esac
		shift
	done
}

set_pair() {
	#@ Update message with key-value pair
	[ "$key" ] && [ "$val" ] && {
		#| Unformatted key-value pair
		pair_log="${key}${sep}${val}"

		#| Formatted key-value pair
		pair_fmt="${key}${sep}${val_fmt:-$val}"
	}
}

set_level() {
	#@ Append the level to the message.
	case "$lvl" in
	error)
		lvl_log="[ERROR] "
		lvl_fmt="${FMT_ERROR}${lvl_log}${FMT_NORMAL}"
		;;
	warn)
		lvl_log="[ WARN] "
		lvl_fmt="${FMT_WARN}${lvl_log}${FMT_NORMAL}"
		;;
	info)
		lvl_log="[ INFO] "
		lvl_fmt="${FMT_INFO}${lvl_log}${FMT_NORMAL}"
		;;
	debug)
		lvl_log="[DEBUG] "
		lvl_fmt="${FMT_DEBUG}${lvl_log}${FMT_NORMAL}"
		;;
	trace)
		lvl_log="[TRACE] "
		lvl_fmt="${FMT_TRACE}${lvl_log}${FMT_NORMAL}"
		;;
	*) unset lvl ;;
	esac

	[ -n "$hide_lvl" ] && unset lvl
}

#@ Get thetimestamp
# timestamp="$(printf "[%s] " "$(fetch.time)")"

# #@ Write message to the log
# [ "$log" ] && {

# 	#@ Sanitize the message by removing all terminal formatting codes
# 	msg_log="$(printf "%s" "${msg:-$pair_log}" |
# 		sed 's/\x1B\[[0-9;]*[mGK]//g' |
# 		sed 's/(B\[[0-9;]*[mGK]//g' |
# 		sed 's/(B//g')"

# 	#@ Create the log directory if it does not exist
# 	# printf "%s%s%s\n" "$timestamp" "$lvl_log" "$msg_log" |
# 	# 	tee -a "$log" >/dev/null
# }

#@ Write message to the console
# [ "${VERBOSITY_LEVEL:-0}" -eq "${VERBOSITY_LEVEL_QUIET:-0}" ] && exit 0

# case "$VERBOSITY_LEVEL" in
# 0) return 0 ;;
# 1) return 0 ;;
# 2) return 0 ;;
# 3) return 0 ;;
# 4) return 0 ;;
# *) ;;
# esac

pout-repeat --line "${ln_lead:-0}"
printf "%s" "$msg"
# if [ "$pad" ]; then
# 	printf "%${padding}s%s%s" "${key_fmt:-"$key"}" "$sep" "${val_fmt:-"$val"}"
# else
# 	msg="${msg:-"${key_fmt:-"$key"}${sep}${val_fmt:-"$val"}"}"
# 	[ "$show_timestamp" ] || unset timestamp
# 	printf "%s%s%s" "$timestamp" "$lvl_fmt" "$msg"
# fi

pout-repeat --line "${ln_trail:-0}"
