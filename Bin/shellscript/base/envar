#!/bin/sh

main() {
    set_defaults
    parse_arguments "$@"
    execute_process
}

set_defaults() {
    unset prefix value export_var cache_var
    scr_name="${0##*/}"
    scr_dir="${0%/*}"
    scr_usage="$(printf "[OPTIONS] <VARIABLE NAME> [VARIABLE VALUE]")"
    scr_version="1.0"
    exit_code=0
    debug=true
    debug_pad=20
    # init=true
    delimiter='_'
    scope="cache"
    cache_path_local="${XDG_CACHE_HOME:-$HOME/.cache}/envar"
    cache_path_global="$cache_path_local" #TODO: How to set globally, for all users?
    cache_setting="export"
}

parse_arguments() {
    while [ "$#" -ge 1 ]; do
        case "$1" in
        -h) printu 0 ;;
        --help) printh ;;
        -v | --version) printv ;;
        --debug) debug=true ;;
        --init | --load) init=true ;;
        --exe | --cmd | --command) type="command" ;;
        --path) type="path" ;;
        --alias) type="alias" ;;
        -cfg | --config)
            type="CONFIG"
            [ "$#" -lt 2 ] && printf "Missing value: %s\n" \
                "$1" && printu 1
            val="$2"
            shift
            ;;
        --global | --export | --cache) scope="global" ;;
        --local) scope="local" ;;
        --no-cache) unset cache ;;
        --prefix)
            prefix="$2"
            shift
            ;;
        --suffix)
            suffix="$2"
            shift
            ;;
        *) key="$1" ;;
        esac
        shift
    done

    #@ Set the value argument
    case "$(printf "%s" "$type" | tr '[:upper:]' '[:lower:]')" in
    command)
        prefix="${prefix:-$type}"
        suffix="${suffix:-}"
        val_arg="--exe"
        ;;
    path)
        prefix="${prefix:-$type}"
        suffix="${suffix:-}"
        val_arg="--env"
        ;;
    config)
        suffix="${suffix:-CONFIG}"
        val_arg="--env"
        ;;
    alias)
        cache_setting="alias"
        prefix="${prefix:-$type}"
        suffix="${suffix:-}"
        val_arg="--env"
        ;;
    *) ;;
    esac

    printd prefix "$prefix"
    printd key "$key"
    printd suffix "$suffix"
    printd val_arg "$val_arg"

    #@ Set the value
    [ -n "$val_arg" ] && [ -z "$val" ] &&
        val="$(resolve_key "$val_arg" "$key")"
    printd val "$val"

}

execute_process() {
    #@ If the key is undefined, check the variable PATH_ENVAR_CACHE is defined. Load it if so or create it if it's not
    if [ -z "$key" ]; then
        manage_cache && return "$?"
    fi

    #@ Generate variable name
    key=$(
        normalize_key \
            --prefix "$prefix" \
            --suffix "$suffix" \
            --delimiter "$delimiter" \
            --uppercase \
            --key "$key"
    ) && printd key "$key"

    #@ If the val is not defined then return the system definition of the key
    [ "$val" ] || {
        get_env "$key"
        return 0
    }

    #@ Cache the variable, if required
    if [ -n "$cache_var" ]; then

        #@ Set the cache path per scope
        case "$scope" in
        local) cache_path="$cache_path_local" ;;
        global) cache_path="$cache_path_global" ;;
        esac

        #@ Write the variable pair to the cache
        manage_cache \
            --key "$key" \
            --val "$val" \
            --path "$cache_path" \
            --type "$cache_setting"
    fi
}

manage_cache() {
    while [ "$#" -ge 1 ]; do
        case "$1" in
        --pair)
            __pair="$2"
            shift
            ;;
        --key)
            __key="$2"
            shift
            ;;
        --val)
            __val="$2"
            shift
            ;;
        --path)
            __path="$2"
            shift
            ;;
        --type)
            __type="$2"
            shift
            ;;
        # *) break ;;
        esac
    done

    #@ Set the cache path variable
    __path="${__path:-$PATH_ENVAR_CACHE}"

    if [ -f "$__path" ]; then
        printd "Loaded cache file" "$__path"
    else
        trap 'rm -f "$__path"' EXIT INT TERM
        __path="$(get_temp_path "envar")"
        printd "Created cache file" "$__path"
    fi

    #@ Ensure the cache directorry allows writing
    if [ -w "$(dirname "$__path")" ]; then

        #@ Check if the cache file exists, create it if not
        if [ -f "$__path" ]; then

            #@ Add the variable pair to the cache
            if [ -n "$__pair" ]; then
                printf "%s%s\n" "$__type" "$__pair" >>"$__path"
            elif [ -n "$__key" ] && [ -n "$__val" ]; then
                printf "%s%s=%s\n" "$__type" "$__key" "$__val" >>"$__path"
            fi
        else
            #@ Create the cache file and include the path as the first variable
            mkdir -p "$(dirname "$__path")"
            printf '# Initialized at: %s\n' "$(date '+%Y-%m-%d %H:%M:%S')" >>"$__path"
        fi
    else
        printf "Unable to write to cache path: %s" "$__path"
        return 1
    fi

    #@ Set the cache path
    export __path
    . "$__path" #TODO: Is this even working? Can the environment be loaded even though this scripts is be executed in a subshell?

    #@ Return the cache path, maybe needed to export properly
    printf "%s" "$__path"

    #@ Clean up temporary variables
    unset __pair __key __val __path
}

printu() {
    exit_code=${1:-1}

    printf 'USAGE: %s %s\n' "$scr_name" "$usage"
    printf '\nOptions:\n'
    printf '  --prefix <string>   Set the prefix for the variable name\n'
    printf '  --suffix <string>   Set the suffix for the variable name\n'
    printf '  --export            Export the variable\n'
    printf '  --cache             Cache the variable\n'
    printf '  --debug             Debug mode (do not set the variable)\n'
    printf '  --exe               Set the value as the path to an executable PATH_BASENAME\n'
    printf '  --path <path>       Set the value as the path to a file\n'

    exit "$exit_code"
}

printh() {
    printf '%s [v.%s]\n' "$scr_name" "$scr_version"
    printf 'USAGE:\n'
    printf '  <script_name> [OPTIONS] <NAME> [VALUE]\n\n'

    printf 'DESCRIPTION:\n'
    printf '  Sets environment variables with optional prefix and suffix.\n'
    printf '  Allows export, caching, and a simulation mode.\n'
    printf '  Checks for the existence of a variable using fuzzy finding.\n\n'

    printf 'OPTIONS:\n'
    printf '  --help              Show this help message and exit\n'
    printf '  --version           Show program version and exit\n\n'

    printf 'ARGUMENTS:\n'
    printf '  --prefix <string>   Set the prefix for the variable name\n'
    printf '                       A string that precedes the variable name.\n\n'
    printf '  --suffix <string>   Set the suffix for the variable name\n'
    printf '                       A string that follows the variable name.\n\n'
    printf '  --export            Export the variable\n'
    printf '                       Make it accessible from child processes.\n\n'
    printf '  --cache             Cache the variable\n'
    printf '                       Store the value in a cache file for quick access.\n\n'
    printf '  --debug             Debug mode (do not set the variable)\n'
    printf '                       Prints the value for debugging purposes.\n\n'
    printf '  --exe               Get the path to an executable\n'
    printf '                       Check if an executable is available on the system.\n\n'
    printf '  --cmd               Alias for --exe\n'
    printf '  --command           Alias for --exe\n'
    printf '  --path              Get the path to a file\n'
    printf '                       Check if a file exists.\n\n'

    printf 'RETURNS:\n'
    printf '  This script does not return a value, but modifies environment variables.\n\n'

    printf 'EXAMPLES:\n'
    printf '  %s --path /usr/bin/python\n' "$scr_name"
    printf '  > PATH_PYTHON=/path/to/python\n\n'
    printf '  %s --prefix MY_ --suffix _VAR --path /usr/bin/python\n' "$scr_name"
    printf '  > MY_PYTHON_VAR=/path/to/python\n\n'
    printf '  %s --exe /usr/bin/python\n\n' "$scr_name"

    printf 'NOTE:\n'
    printf '  Ensure you have the necessary permissions to modify environment variables.\n'

    exit 0
}

printv() {
    printf "%s\n" "$scr_version"
}

printd() {
    #@ Return if debug mode is not enabled
    if [ -z "$debug" ] || [ "$debug" -eq 0 ] >/dev/null 2>&1; then
        return 0
    fi

    #@ Print the debug message as a key-value pair if multiple arguments are provided
    if [ "$#" -eq 2 ]; then
        printf '[DEBUG] %*s |> %-*s\n' "$debug_pad" "$1" "$debug_pad" "$2"
    else
        printf '[DEBUG] %s\n' "$1"
    fi
}

get_env() {
    #@ Return if no argument is provided
    [ -z "$1" ] && return 1

    #@ Define the common grep arguments
    grep_args="-i --color=always -- '^'$1'[^=]*'"

    #@ Return the environment variable, using grep for fuzzy finding and falling back to printf
    if [ "$COMMAND_ENV" ] && [ "$COMMAND_RG" ]; then
        env | rg "$grep_args" | sort -u
    elif command -v env >/dev/null 2>&1; then
        if command -v rg >/dev/null 2>&1; then
            env | eval rg "$grep_args"
        else
            env | eval grep "$grep_args"
        fi | sort -u
    else
        __var=$(eval "printf \"%s\" \"\${$1}\"")
        if [ -n "$__var" ]; then
            printf '%s=%s' "$1" "$__var"
        else
            printf '%s is not set\n' "$1"
        fi
    fi
}

get_temp_path() {
    case "$(uname -s)" in
    MINGW* | CYGWIN*)
        # Git Bash on Windows
        printf '%s' "$(cygpath -w "${TEMP:-${TMP:-/tmp}}")/${1}.$$"
        ;;
    *)
        # Unix-like systems
        printf '%s' "${TMPDIR:-/tmp}/${1}.$$"
        ;;
    esac
}

normalize_key() {
    __delim="_"

    while [ "$#" -gt 0 ]; do
        case "$1" in
        -l | -*lower*) __case="lowercase" ;;
        -u | -*upper*) __case="uppercase" ;;
        -d | -*delim* | -*sep*)
            __delim="$2"
            shift
            ;;
        -p | --prefix)
            __prefix="$2"
            shift
            ;;
        -s | --suffix)
            __suffix="$2"
            shift
            ;;
        -k | --key)
            __key="${__key:+$__key${__delim}}$2"
            shift
            ;;
        *) __key="${__key:+$__key${__delim}}$1" ;;
        esac
        shift
    done

    #@ Ensure a key is provided
    if [ -z "$__key" ]; then
        if [ -n "$__prefix" ] || [ -n "$__suffix" ]; then
            printf 'Error: Key is missing. Cannot add prefix or suffix\n' >&2
        else
            printf 'Error: Key is missing. Nothing to normalize\n' >&2
        fi
        exit 2
    fi

    #@ Add prefix and suffix, if provided
    [ "$__prefix" ] && __key="${__prefix}_${__key}"
    [ "$__suffix" ] && __key="${__key}_${__suffix}"

    #@ Replace invalid characters with the delimiter
    __key="$(clean_string "$__key" "$__delim")"

    #@ Modify the case if required
    case "$__case" in
    u*)
        LC_ALL=C __key=$(printf '%s' "$__key" | tr '[:lower:]' '[:upper:]')
        ;;
    l*)
        LC_ALL=C __key=$(printf '%s' "$__key" | tr '[:upper:]' '[:lower:]')
        ;;
    *) ;;
    esac

    #@ Return the normalized key
    printf '%s' "$__key"

    #@ Clean up temporary variables
    unset __key __prefix __suffix __delim __case __clean_key
}

resolve_key() {
    while [ "$#" -ge 1 ]; do
        case "$1" in
        --exe | --cmd | --command) command -v "$2" ;;
        --path) readlink -f "$2" ;;
        *) printf '%s' "$2" ;;
        esac
        shift
    done
}

clean_string() {
    printf '%s' "$1" | sed "s/[^[:alnum:]_]/'${2:-_}'/g"
}

main "$@"
