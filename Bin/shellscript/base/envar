#!/bin/sh

main() {
	set_defaults
	parse_arguments "$@"
	initialize_output
	set_overrides
	# execute_process
}

set_defaults() {
	unset prefix value export_var cache_var
	scr_name="${0##*/}"
	scr_dir="${0%/*}"
	scr_usage="$(printf "[OPTIONS] <VARIABLE NAME> [VARIABLE VALUE]")"
	scr_version="1.0"
	exit_code=0
	debug=
	debug_pad=24
	# init=true
	delimiter='_'
	scope="local"
	out_dir="${DOTS:-$HOME}/.cache"
	cache_setting="export"
}

parse_arguments() {
	while [ "$#" -ge 1 ]; do
		case "$1" in
		-h) printu 0 ;;
		--help) printh ;;
		-v | --version) printv ;;
		--debug) debug=true ;;
		-*out*)
			[ "$#" -lt 2 ] && printu --arg "$1" --code 1
			out_dir="$2"
			shift
			;;
		--init | --load) init=true ;;
		-*dot*)
			mod="uppercase"

			if [ "$#" -eq 2 ]; then
				key="DOTS"
				val="$2"
			elif [ "$#" -ge 3 ]; then
				shift
				type="DOTS"
				val="$1"
				key="${key:+$key_}$2"
			fi
			;;
		--exe | --cmd | --command) type="command" ;;
		--path) type="path" ;;
		--alias) type="alias" ;;
		-cfg | --config)
			type="CONFIG"
			[ "$#" -lt 2 ] && printf "Missing value: %s\n" \
				"$1" && printu 1
			val="$2"
			shift
			;;
		--global | --export) scope="global" ;;
		--local) scope="local" ;;
		--no-cache) unset cache ;;
		--prefix)
			prefix="$2"
			shift
			;;
		--suffix)
			suffix="$2"
			shift
			;;
		--key)
			mod="none"
			key="$2"
			shift
			;;
		--val)
			mod="none"
			val="$2"
			shift
			;;
		*) key="$1" ;;
		esac
		shift
	done
}

initialize_output() {
	#@ Create the output directory if it doesn't exist
	mkdir -p "$out_dir"

	#@ Initialize the cache file
	cache_path="$(generate_file --ext ".env")"

	#@ Initialize the log file
	log_path="$(generate_file --ext ".log")"
}

generate_file() {
	#@ Parse the arguments
	while [ "$#" -ge 1 ]; do
		case "$1" in
		--dir) __dir="$2" ;;
		--name) __name="$2" ;;
		--ext) __ext="$2" ;;
		--file) __file="$2" ;;
		*) ;;
		esac
		shift
	done

	#@ Set the function environment
	__dir="${__dir:-"$out_dir"}"
	__name="${__name:-"$scr_name"}"
	__ext="${__ext:-}"
	__file="${__dir}/${__name}${__ext}"

	#@ Ensure the output directory exists
	mkdir -p "$__dir" || {
		printf "ERROR: Failed to create output directory '%s'\n" "$__dir" >&2
		return 1
	}

	#@ Create the output file if it doesn't exist
	[ -f "$__file" ] || {
		printf '# Generated by envar at %s\n\n' \
			"$(date '+%Y-%m-%d %H:%M:%S')"
	} >"$__file"

	#@ Return the file path
	printf "%s" "$__file"
}

set_overrides() {

	return
	#@ Set the prefix
	prefix="${prefix:-$type}"

	#@ Set the value argument
	case "$(printf "%s" "$type" | tr '[:upper:]' '[:lower:]')" in
	cmd)
		suffix="${suffix:-}"
		val_arg="--exe"
		;;
	path)
		suffix="${suffix:-}"
		val_arg="--env"
		;;
	config)
		suffix="${suffix:-CONFIG}"
		val_arg="--env"
		;;
	alias)
		cache_setting="alias"
		val_arg="--env"
		;;
	*) ;;
	esac

	#@ Set the value
	[ -n "$val_arg" ] && [ -z "$val" ] &&
		val="$(resolve_key "$val_arg" "$key")"

	#@ Debug
	printd "$cache_path" "cache_path"
	printd "$mod" "Case" "Modification"
	printd "$prefix" "Prefix"
	printd "$key" "Key"
	printd "$suffix" "Suffix"
	printd "$val" "Value"
	printd "$val_arg" "Val_arg"
}

execute_process() {
	#@ Initialize the cache path
	#TODO: This should be done in the manage_cache function
	if [ -z "$key" ] && [ "$cache_path" ]; then
		mkdir -p "$(dirname "$cache_path")"

		[ -f "$cache_path" ] ||
			printf '%s\n\%s: %s\n\n' \
				"#!/bin/sh" \
				"# Generated by envar at" \
				"$(date '+%Y-%m-%d %H:%M:%S')" >"$cache_path"

		printf "%s\n" "$cache_path"
		# manage_cache --path "$cache_path"
		exit "$?"
	fi

	#@ Generate variable name
	key=$(
		normalize_key \
			--prefix "$prefix" \
			--suffix "$suffix" \
			--delimiter "$delimiter" \
			--mod "$mod" \
			--key "$key"
	)
	printd "$key" "Normalized" "Key"

	#@ If the val is not defined then return the system definition of the key
	[ "$val" ] || {
		get_env "$key"
		return 0
	}

	#@ Cache the variable, if required
	if [ -n "$cache_var" ]; then

		#@ Set the cache path per scope
		case "$scope" in
		local) cache_path="${cache_path:-"$cache_path_local" }" ;;
		global) cache_path="${cache_path:-"$cache_path_global"}" ;;
		esac

		#@ Write the variable pair to the cache
		# manage_cache \
		# 	--key "$key" \
		# 	--val "$val" \
		# 	--path "$cache_path" \
		# 	--type "$cache_setting"
	fi
}

manage_cache() {
	while [ "$#" -ge 1 ]; do
		case "$1" in
		--pair)
			__pair="$2"
			shift
			;;
		--key)
			__key="$2"
			shift
			;;
		--val)
			__val="$2"
			shift
			;;
		--path)
			__path="$2"
			shift
			;;
		--type)
			__type="$2"
			shift
			;;
		# *) break ;;
		esac
	done

	#@ Set the cache path variable
	__path="${__path:-$PATH_ENVAR_CACHE}"
	printd "Path" "$__path"

	# [ -z "$__path" ] && {
	# 	trap 'rm -f "$__path"' EXIT INT TERM
	# 	__path="$(get_temp_path "envar")"
	# 	printd "Created cache file" "$__path"
	# }

	# #@ Ensure the cache directorry allows writing
	# if [ -w "$(dirname "$__path")" ]; then

	# 	#@ Check if the cache file exists, create it if not
	# 	if [ -f "$__path" ]; then

	# 		#@ Add the variable pair to the cache
	# 		if [ -n "$__pair" ]; then
	# 			printf "%s%s\n" "$__type" "$__pair" >>"$__path"
	# 		elif [ -n "$__key" ] && [ -n "$__val" ]; then
	# 			printf "%s%s=%s\n" "$__type" "$__key" "$__val" >>"$__path"
	# 		fi
	# 	else
	# 		#@ Create the cache file and include the path as the first variable
	# 		mkdir -p "$(dirname "$__path")"
	# 		printf '# Initialized at: %s\n' "$(date '+%Y-%m-%d %H:%M:%S')" >"$__path"
	# 	fi
	# else
	# 	printf "Unable to write to cache path: %s" "$__path"
	# 	return 1
	# fi

	#@ Set the cache path
	# export __path
	# . "$__path" #TODO: Is this even working? Can the environment be loaded even though this scripts is be executed in a subshell?

	#@ Return the cache path, maybe needed to export properly
	printf "%s" "$__path"

	#@ Clean up temporary variables
	unset __pair __key __val __path
}

printu() {
	exit_code=${1:-1}

	printf 'USAGE: %s %s\n' "$scr_name" "$usage"
	printf '\nOptions:\n'
	printf '  --prefix <string>   Set the prefix for the variable name\n'
	printf '  --suffix <string>   Set the suffix for the variable name\n'
	printf '  --export            Export the variable\n'
	printf '  --cache             Cache the variable\n'
	printf '  --debug             Debug mode (do not set the variable)\n'
	printf '  --exe               Set the value as the path to an executable PATH_BASENAME\n'
	printf '  --path <path>       Set the value as the path to a file\n'

	exit "$exit_code"
}

printh() {
	printf '%s [v.%s]\n' "$scr_name" "$scr_version"
	printf 'USAGE:\n'
	printf '  <script_name> [OPTIONS] <NAME> [VALUE]\n\n'

	printf 'DESCRIPTION:\n'
	printf '  Sets environment variables with optional prefix and suffix.\n'
	printf '  Allows export, caching, and a simulation mode.\n'
	printf '  Checks for the existence of a variable using fuzzy finding.\n\n'

	printf 'OPTIONS:\n'
	printf '  --help              Show this help message and exit\n'
	printf '  --version           Show program version and exit\n\n'

	printf 'ARGUMENTS:\n'
	printf '  --prefix <string>   Set the prefix for the variable name\n'
	printf '                       A string that precedes the variable name.\n\n'
	printf '  --suffix <string>   Set the suffix for the variable name\n'
	printf '                       A string that follows the variable name.\n\n'
	printf '  --export            Export the variable\n'
	printf '                       Make it accessible from child processes.\n\n'
	printf '  --cache             Cache the variable\n'
	printf '                       Store the value in a cache file for quick access.\n\n'
	printf '  --debug             Debug mode (do not set the variable)\n'
	printf '                       Prints the value for debugging purposes.\n\n'
	printf '  --exe               Get the path to an executable\n'
	printf '                       Check if an executable is available on the system.\n\n'
	printf '  --cmd               Alias for --exe\n'
	printf '  --command           Alias for --exe\n'
	printf '  --path              Get the path to a file\n'
	printf '                       Check if a file exists.\n\n'

	printf 'RETURNS:\n'
	printf '  This script does not return a value, but modifies environment variables.\n\n'

	printf 'EXAMPLES:\n'
	printf '  %s --path /usr/bin/python\n' "$scr_name"
	printf '  > PATH_PYTHON=/path/to/python\n\n'
	printf '  %s --prefix MY_ --suffix _VAR --path /usr/bin/python\n' "$scr_name"
	printf '  > MY_PYTHON_VAR=/path/to/python\n\n'
	printf '  %s --exe /usr/bin/python\n\n' "$scr_name"

	printf 'NOTE:\n'
	printf '  Ensure you have the necessary permissions to modify environment variables.\n'

	exit 0
}

printv() {
	printf "%s\n" "$scr_version"
}

printd() {
	#@ Return if debug mode is not enabled
	if [ -z "$debug" ] || [ "$debug" -eq 0 ] >/dev/null 2>&1; then
		return 0
	fi

	#@ Print the debug message as a key-value pair if multiple arguments are provided
	if [ "$#" -eq 0 ]; then
		printf "\n"
	elif [ "$#" -eq 1 ]; then
		printf "[DEBUG] %s\n" "$1"
	else
		__val="$1"
		shift
		__key="$*"
		printf "[DEBUG] %${debug_pad}s |> %s\n" "$__key" "$__val"
	fi
}

get_env() {
	#@ Return if no argument is provided
	[ -z "$1" ] && return 1

	#@ Define the common grep arguments
	grep_args="-i --color=always -- '^'$1'[^=]*'"

	#@ Return the environment variable, using grep for fuzzy finding and falling back to printf
	if [ "$COMMAND_ENV" ] && [ "$COMMAND_RG" ]; then
		env | rg "$grep_args" | sort -u
	elif command -v env >/dev/null 2>&1; then
		if command -v rg >/dev/null 2>&1; then
			env | eval rg "$grep_args"
		else
			env | eval grep "$grep_args"
		fi | sort -u
	else
		__var=$(eval "printf \"%s\" \"\${$1}\"")
		if [ -n "$__var" ]; then
			printf '%s=%s' "$1" "$__var"
		else
			printf '%s is not set\n' "$1"
		fi
	fi
}

get_temp_path() {
	case "$(uname -s)" in
	MINGW* | CYGWIN*)
		# Git Bash on Windows
		printf '%s' "$(cygpath -w "${TEMP:-${TMP:-/tmp}}")/${1}.$$"
		;;
	*)
		# Unix-like systems
		printf '%s' "${TMPDIR:-/tmp}/${1}.$$"
		;;
	esac
}

normalize_key() {
	__delim="_"

	while [ "$#" -gt 0 ]; do
		case "$1" in
		--mod)
			__mod="$2"
			shift
			;;
		-l | -*lower*) __mod="lowercase" ;;
		-u | -*upper*) __mod="uppercase" ;;
		-d | -*delim* | -*sep*)
			__delim="$2"
			shift
			;;
		-p | --prefix)
			__prefix="$2"
			shift
			;;
		-s | --suffix)
			__suffix="$2"
			shift
			;;
		-k | --key)
			__key="${__key:+$__key${__delim}}$2"
			shift
			;;
		*) __key="${__key:+$__key${__delim}}$1" ;;
		esac
		shift
	done

	#@ Ensure a key is provided
	if [ -z "$__key" ]; then
		if [ -n "$__prefix" ] || [ -n "$__suffix" ]; then
			printf 'Error: Key is missing. Cannot add prefix or suffix\n' >&2
		else
			printf 'Error: Key is missing. Nothing to normalize\n' >&2
		fi
		exit 2
	fi

	#@ Add prefix and suffix, if provided
	[ "$__prefix" ] && __key="${__prefix}_${__key}"
	[ "$__suffix" ] && __key="${__key}_${__suffix}"

	#@ Replace invalid characters with the delimiter
	__key="$(clean_string "$__key" "$__delim")"

	#@ Modify the case if required
	case "$__mod" in
	u*)
		LC_ALL=C __key=$(printf '%s' "$__key" | tr '[:lower:]' '[:upper:]')
		;;
	l*)
		LC_ALL=C __key=$(printf '%s' "$__key" | tr '[:upper:]' '[:lower:]')
		;;
	*) ;;
	esac

	#@ Return the normalized key
	printf '%s' "$__key"

	#@ Clean up temporary variables
	unset __key __prefix __suffix __delim __mod __clean_key
}

resolve_key() {
	while [ "$#" -ge 1 ]; do
		case "$1" in
		--exe | --cmd | --command) command -v "$2" ;;
		--path) readlink -f "$2" ;;
		*) printf '%s' "$2" ;;
		esac
		shift
	done
}

clean_string() {
	printf '%s' "$1" | sed "s/[^[:alnum:]_]/'${2:-_}'/g"
}

main "$@"
