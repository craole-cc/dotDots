#!/bin/sh
# shellcheck enable=all
set -eu

main() {
  #| Initialization
  trap sanitize_environment EXIT INT TERM
  init_metadata
  parse_arguments "$@"

  #| Validation
  validate_environment

  #| Termination
  execute_process
}

init_metadata() {
  cmd_NAME="absolute"
  cmd_VERSION="1.1.0"
  cmd_AUTHOR="Craole"
  cmd_USAGE="${cmd_NAME} [OPTIONS] <target_path>"
  cmd_DESCRIPTION="normalizes a given target path by resolving symbolic links and removing redundant elements such as '.' and '..'."
}

parse_arguments() {
  while [ $# -gt 0 ]; do
    case $1 in
    -h | --help) terminate_process --usage ;;
    -v | --version) terminate_process --version ;;
    -q | --quiet) verbosity=quiet ;;
    -d=* | --verbose=*) verbosity="${1#*=}" ;;
    -d | --verbose)
      case "$2" in
      */*) verbosity="debug" ;;
      *)
        if [ -n "${2:-}" ]; then
          verbosity="$2"
          shift
        else
          verbosity="debug"
        fi
        ;;
      esac
      ;;
    -*) terminate_process --error opt "$1" ;;
    *) target_path="$1" ;;
    esac
    shift
  done

  case "${verbosity:-}" in
  0 | quiet | off | false) verbosity=0 ;;
  1 | error) verbosity=1 ;;
  2 | warn*) verbosity=2 ;;
  5 | trace) verbosity=5 ;;
  4 | debug) verbosity=4 ;;
  3 | info | on | *) verbosity=3'' ;;
  esac
}

validate_environment() {
  #@ Check if target path is provided as an argument
  [ -n "${target_path}" ] || terminate_process --error arg

  #@ Check if target path exists and is accessible
  [ -e "${target_path}" ] ||
    terminate_process --error path "${target_path}"
}

execute_process() {
  #@ Initalize variables

  #@ Use realpath if available as it is more efficient
  if command -v realpathf >/dev/null 2>&1; then
    normalized_path="$(realpath -- "${target_path}")"
  else
    #@ Initialize path parts variables
    normalized_path=""
    path_dir="$(pwd -P)"
    path_name="$(basename -- "${target_path}")"
    path_part=""

    #@ Update the target path to respect symbolic links
    path_part="$(

      #@ Follow the symbolic link recursively until it points to an actual file or directory
      cd -P -- "$(dirname -- "${target_path}")" ||
        terminate_process --error cd "${target_path}"

      #@  Print value of symbolic link normalized path
      case "${path_name}" in
      .) printf "%s""${path_dir}" ;;
      *) printf '%s/%s\n' "${path_dir}" "${path_name}" ;;
      esac
    )"

    #@ Split the path into components
    while [ -n "${path_part}" ]; do

      #@ Remove leading slashes
      path_part="${path_part#/}"

      #@ Extract the next path component
      next_path_part="${path_part%%/*}"

      #@ Remove the extracted component from the remaining path
      path_part="${path_part#"${next_path_part}"}"

      #@ Remove trailing slashes
      path_part="${path_part#/}"

      #@ Replace any occurrence of '..' or '../' with its corresponding directory
      case "${next_path_part}" in
      ../*)
        echo dotdotslash
        normalized_path="$(dirname "${normalized_path}")/${next_path_part#../}"
        ;;
      ..)
        echo dotdot
        normalized_path="$(dirname "${normalized_path}")"
        ;;
      *)
        echo other
        normalized_path="${normalized_path}/${next_path_part}"
        ;;
      esac
    done

    printf "%s" "${normalized_path}"
  fi

  terminate_process --output "${normalized_path}"
}

terminate_process() {
  case "$1" in
  --error) display_info "$1-$2" "$3" ;;
  --output) display_info "$1" "$2" ;;
  *) ;;
  esac
}

sanitize_environment() {
  #@ Remove varibles
  unset verbosity
  unset target_path
  unset normalized_path
  unset target_path
  unset next_target_path_component
  unset error_generated
}

display_info() {
  case "$1" in
  --error*)
    [ "${verbosity}" -eq 0 ] && return
    case "$1" in
    *path) printf "Invalid path: %s" "$2" ;;
    *circ) printf "Circular symbolic link: %s" "$2" ;;
    *info) printf "Invalid verbosity level: %s" "$2" ;;
    *arg) printf "<target_path> required \nUsage: %s\n" "${cmd_USAGE}" ;;
    *opt) printf "Unrecognized option: %s" "$2" ;;
    *cd) printf "Change directory operation failed" ;;
    *) ;;
    esac
    ;;
  --output)
    case "${verbosity}" in
    3 | on | info) printf "%s\n" "${normalized_path}" ;;
    4 | debug | trace)
      printf "    Verbosity: %s\n" "${verbosity}"
      printf "  Target Path: %s\n" "${target_path}"
      printf "Absolute Path: %s\n" "${normalized_path}"
      ;;
    0 | off | quiet | *) ;;
    esac
    ;;
  --version)
    printf "%s" "${cmd_VERSION}"
    ;;
  --usage)
    cat <<USAGE
Description:
'${cmd_NAME}' by ${cmd_AUTHOR} ${cmd_DESCRIPTION}

Usage:
${cmd_USAGE}

Options:
  -h, --help       Show detailed help information and exit.
  -v, --version    Show the script version number and exit.
  -d, --verbose    Display additional information during execution: quiet, info (default), debug.
  -q, --quiet      Supress all output. Error flag will still work.

Arguments:
  <target_path>       The path to normalize.

Exit status:
  0                   The path was successfully normalized.
  1                   An error occurred.

Examples:
  ${cmd_NAME} -d=debug ~/../../usr/bin
  ${cmd_NAME} /var/log/../lib --verbose info
  ${cmd_NAME} /var/run
USAGE
    ;;
  *) printf "%s\n" "$*" ;;
  esac
}

main "$@"
