#!/bin/sh
# shellcheck enable=all
set -eu

main() {
  #| Initialization
  trap sanitize_environment EXIT INT TERM
  init_metadata
  parse_arguments "$@"

  #| Validation
  validate_environment

  #| Termination
  execute_process
}

init_metadata() {
  cmd_NAME="absolute"
  cmd_VERSION="1.1.0"
  cmd_AUTHOR="Craole"
  cmd_USAGE="${cmd_NAME} [OPTIONS] <target_path>"
  cmd_DESCRIPTION="normalizes a given target path by resolving symbolic links and removing redundant elements such as '.' and '..'."
}

parse_arguments() {
  while [ $# -gt 0 ]; do
    case $1 in
    -h | --help) terminate_process --usage ;;
    -v | --version) terminate_process --version ;;
    -q | --quiet) verbosity=quiet ;;
    -d=* | --verbose=*) verbosity="${1#*=}" ;;
    -d | --verbose)
      case "$2" in
      */*) verbosity="debug" ;;
      *)
        if [ -n "${2:-}" ]; then
          verbosity="$2"
          shift
        else
          verbosity="debug"
        fi
        ;;
      esac
      ;;
    -*) terminate_process --error opt "$1" ;;
    *) target_path="$1" ;;
    esac
    shift
  done

  case "${verbosity:-}" in
  0 | quiet | off | false) verbosity=0 ;;
  1 | error) verbosity=1 ;;
  2 | warn*) verbosity=2 ;;
  5 | trace) verbosity=5 ;;
  4 | debug) verbosity=4 ;;
  3 | info | on | *) verbosity=3'' ;;
  esac
}

validate_environment() {
  #@ Check if target path is provided as an argument
  [ -n "${target_path}" ] || terminate_process --error arg

  #@ Check if target path exists and is accessible
  [ -e "${target_path}" ] ||
    terminate_process --error path "${target_path}"
}

normalize_path() {
  #@ Initialize variables
  input_path="$1"
  abs_path=""
  result=""

  #@ Handle absolute vs. relative paths
  case "${input_path}" in
  /*) abs_path="${input_path}" ;;
  *) abs_path="$(pwd)/${input_path}" ;;
  esac

  #@ Set initial slash for absolute paths
  case "${abs_path}" in
  /*) result="/" ;;
  *) ;;
  esac

  #@ Save IFS and set new one for path splitting
  OLDIFS="${IFS}"
  IFS="/"

  #@ Process each component
  for component in ${abs_path}; do
    #@ Skip empty components and current directory
    if [ -z "${component}" ] || [ "${component}" = "." ]; then
      continue
    fi

    if [ "${component}" = ".." ]; then
      #@ Go up one directory level
      if [ "${result}" = "/" ]; then
        #@ Stay at root if already there
        continue
      elif [ -z "${result}" ]; then
        #@ For relative paths starting with ..
        result="../"
      else
        #@ Remove trailing slash if present
        result="${result%/}"

        #@ Go up one level
        result="$(dirname "${result}")"

        #@ Handle empty result (happens when we're at the top of a relative path)
        [ "${result}" = "." ] && result=""
      fi
    else
      #@ Add component to result
      if [ "${result}" = "/" ]; then
        result="/${component}"
      elif [ -z "${result}" ]; then
        result="${component}"
      else
        result="${result}/${component}"
      fi
    fi
  done

  #@ Restore IFS
  IFS="${OLDIFS}"

  #@ Ensure we return at least "/" for root directory or "." for empty
  if [ -z "${result}" ]; then
    result="."
  fi

  #@ Return the normalized path
  printf "%s" "${result}"
}

resolve_path() {
  [ -n "${1:-}" ] || {
    terminate_process --error "resolve_path" "missing target path to resolve"
    exit 2
  }

  target="$1"
  max_depth=50 # Prevent infinite recursion with deeply nested symlinks
  current_depth=${2:-0}

  #@ Check recursion depth to prevent infinite loops
  if [ "${current_depth}" -ge "${max_depth}" ]; then
    printf "Error: Maximum symlink recursion depth reached (%s)\n" "${max_depth}" >&2
    return 1
  fi

  #@ Resolve the target directory and get its physical path
  if ! physical_dir="$(cd -P "$(dirname "${target}")" 2>/dev/null && pwd -P)"; then
    #@ Return original if directory doesn't exist
    printf "%s" "${target}"
    return 1
  fi

  physical_base="$(basename "${target}")"
  physical_path="${physical_dir}/${physical_base}"

  #@ Check if the basename is a symlink and resolve it
  if [ -L "${physical_path}" ]; then
    link_target="$(readlink "${physical_path}")"

    #@ Handle relative vs. absolute links
    case "${link_target}" in
    /*) resolved_link="${link_target}" ;;
    *) resolved_link="${physical_dir}/${link_target}" ;;
    esac

    #@ Recursively resolve the link target with incremented depth
    next_depth=$((current_depth + 1))
    resolve_path "${resolved_link}" "${next_depth}"
  else
    #@ Return the fully normalized physical path
    printf "%s" "${physical_path}"
  fi
}

execute_process() {
  #@ Use realpath if available as it is more efficient
  if command -v realpathf >/dev/null 2>&1; then
    normalized_path="$(realpath -- "${target_path}")"
  else
    normalized_path="$(resolve_path "${target_path}")"
  fi

  terminate_process --output "${normalized_path}"
}

terminate_process() {
  case "$1" in
  --error) display_info "${1:-}-${2:-}" "${3:-}" ;;
  --output) display_info "${1:-}" "${2:-}" ;;
  *) ;;
  esac
}

sanitize_environment() {
  #@ Remove varibles
  unset verbosity
  unset target_path
  unset normalized_path
  unset target_path
  unset next_target_path_component
  unset error_generated
}

display_info() {
  case "$1" in
  --error*)
    [ "${verbosity}" -eq 0 ] && return
    case "$1" in
    path) printf "Invalid path: %s" "$2" ;;
    circ) printf "Circular symbolic link: %s" "$2" ;;
    info) printf "Invalid verbosity level: %s" "$2" ;;
    arg) printf "<target_path> required \nUsage: %s\n" "${cmd_USAGE}" ;;
    opt) printf "Unrecognized option: %s" "$2" ;;
    cd) printf "Change directory operation failed" ;;
    *)
      shift
      printf "%b" "$*"
      ;;
    esac
    ;;
  --output)
    case "${verbosity}" in
    3 | on | info) printf "%s\n" "${normalized_path}" ;;
    4 | debug | trace)
      printf "    Verbosity: %s\n" "${verbosity}"
      printf "  Target Path: %s\n" "${target_path}"
      printf "Absolute Path: %s\n" "${normalized_path}"
      ;;
    0 | off | quiet | *) ;;
    esac
    ;;
  --version)
    printf "%s" "${cmd_VERSION}"
    ;;
  --usage)
    cat <<USAGE
Description:
'${cmd_NAME}' by ${cmd_AUTHOR} ${cmd_DESCRIPTION}

Usage:
${cmd_USAGE}

Options:
  -h, --help       Show detailed help information and exit.
  -v, --version    Show the script version number and exit.
  -d, --verbose    Display additional information during execution: quiet, info (default), debug.
  -q, --quiet      Supress all output. Error flag will still work.

Arguments:
  <target_path>       The path to normalize.

Exit status:
  0                   The path was successfully normalized.
  1                   An error occurred.

Examples:
  ${cmd_NAME} -d=debug ~/../../usr/bin
  ${cmd_NAME} /var/log/../lib --verbose info
  ${cmd_NAME} /var/run
USAGE
    ;;
  *) printf "%s\n" "$*" ;;
  esac
}

main "$@"
